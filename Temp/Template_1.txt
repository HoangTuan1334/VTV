import google.generativeai as genai
import requests
from PIL import Image
import io
import base64

# C·∫•u h√¨nh API Key
GEMINI_API_KEY = "AIzaSyDi-soBuW5bmVCncY2ImjtmSONR2AukSng"
genai.configure(api_key=GEMINI_API_KEY)

# Test text generation
print("üß™ TEST 1: Ki·ªÉm tra Text Generation...")
try:
    text_model = genai.GenerativeModel('gemini-2.0-flash-exp')
    response = text_model.generate_content("Say hello in 3 words")
    print(f"‚úÖ Text Generation: OK")
    print(f"   Response: {response.text}")
except Exception as e:
    print(f"‚ùå Text Generation l·ªói: {e}")
    raise

# Test image generation model
print("\nüß™ TEST 2: Ki·ªÉm tra Image Model...")
try:
    image_model = genai.GenerativeModel('gemini-2.5-flash-image')
    print(f"‚úÖ Image Model: gemini-2.5-flash-image ƒë∆∞·ª£c kh·ªüi t·∫°o")
    print(f"   S·∫Ω th·ª≠ t·∫°o ·∫£nh khi ch·∫°y workflow")
except Exception as e:
    print(f"‚ö†Ô∏è Image Model l·ªói: {e}")
    print(f"   C√≥ th·ªÉ model n√†y ch∆∞a kh·∫£ d·ª•ng")

print("\n‚úÖ API Key ho·∫°t ƒë·ªông t·ªët!")
print("üìå Text generation s·∫µn s√†ng")
print("üìå Image model: gemini-2.5-flash-image")



# üìö Import th∆∞ vi·ªán
import json
import os
import random
import base64
import time
from PIL import Image, ImageDraw, ImageFont
from pathlib import Path
import google.generativeai as genai
import requests
from io import BytesIO




# ‚öôÔ∏è C·∫•u h√¨nh API Keys
GEMINI_API_KEY = "AIzaSyCwhqIs7GrVi1G6wgtejD_w_niFFQws6mo"

# Kh·ªüi t·∫°o Gemini
genai.configure(api_key=GEMINI_API_KEY)

# Model cho sinh k·ªãch b·∫£n (text)
text_model = genai.GenerativeModel('gemini-2.0-flash-exp')

# Model cho sinh ·∫£nh
try:
    image_model = genai.GenerativeModel('gemini-2.5-flash-image')
    print("‚úÖ ƒê√£ c·∫•u h√¨nh Gemini API")
    print(f"   - API Key: {'‚úì' if GEMINI_API_KEY else '‚úó'}")
    print(f"   - Text Model: gemini-2.0-flash-exp ‚úì")
    print(f"   - Image Model: gemini-2.5-flash-image ‚úì")
except Exception as e:
    print(f"‚ö†Ô∏è L·ªói kh·ªüi t·∫°o image model: {e}")
    print("   S·∫Ω th·ª≠ g·ªçi API tr·ª±c ti·∫øp khi t·∫°o ·∫£nh")
    image_model = None



# üé® C·∫•u h√¨nh trang v√† layouts - S·ª¨ D·ª§NG K√çCH TH∆Ø·ªöC CHU·∫®N GEMINI
PAGE_W, PAGE_H = 2100, 2970  # A4 portrait (300 DPI)
MARGIN = 50
GAP = 20

# ‚≠ê K√çCH TH∆Ø·ªöC CHU·∫®N GEMINI (kh√¥ng c·∫ßn resize)
GEMINI_SIZES = {
    "1:1": (1024, 1024),
    "2:3": (832, 1248),
    "3:2": (1248, 832),
    "3:4": (864, 1152),
    "4:3": (1152, 864),
    "4:5": (896, 1152),
    "5:4": (1152, 896),
    "9:16": (768, 1344),
    "16:9": (1344, 768),
    "21:9": (1536, 672),
}

# ‚≠ê LAYOUTS M·ªöI: CH·ªà D√ôNG K√çCH TH∆Ø·ªöC CHU·∫®N GEMINI - C√ÇN ƒê·ªêI & H√ÄI H√íA
# M·ªói layout: 4-6 panels, k√≠ch th∆∞·ªõc ch√≠nh x√°c t·ª´ GEMINI_SIZES
# C√°c panel ƒë∆∞·ª£c b·ªë tr√≠ c√¢n ƒë·ªëi, d·ªÖ nh√¨n, v·ª´a kh√≠t trong trang A4 (2100√ó2970)
layouts = {
    # "layout_1": [  # 4 panels - 2x2 grid vu√¥ng ƒë·ªÅu (1:1)
    #     (MARGIN, MARGIN, 1024, 1024),
    #     (MARGIN + 1024 + GAP, MARGIN, 1024, 1024),
    #     (MARGIN, MARGIN + 1024 + GAP, 1024, 1024),
    #     (MARGIN + 1024 + GAP, MARGIN + 1024 + GAP, 1024, 1024),
    # ],
    
    "layout_2": [  # 5 panels - 1 wide + 2 middle + 2 bottom
        (MARGIN, MARGIN, 2000, 880),                    # Panel 1: wide cinematic (16:9)
        (MARGIN, MARGIN + 870 + GAP, 1000, 1000),       # Panel 2: left middle (1:1)
        (MARGIN + 1000 + GAP, MARGIN + 870 + GAP, 1000, 1000),  # Panel 3: right middle (1:1)
        (MARGIN, MARGIN + 870 + 1000 + 2*GAP, 1000, 1000),      # Panel 4: bottom left (1:1)
        (MARGIN + 1000 + GAP, MARGIN + 870 + 1000 + 2*GAP, 1000, 1000),  # Panel 5: bottom right (1:1)
    ],
    
    "layout_5": [  # 6 panels - 1 wide + 2 big + 3 bottom taller
        (MARGIN, MARGIN, 2000, 850),  # 1Ô∏è‚É£ top wide (16:9)

        # H√†ng gi·ªØa: 2 khung l·ªõn
        (MARGIN, MARGIN + 850 + GAP, 980, 1050),  # 2Ô∏è‚É£ large left (1:1)
        (MARGIN + 980 + GAP, MARGIN + 850 + GAP, 980, 1050),  # 3Ô∏è‚É£ large right (1:1)

        # H√†ng cu·ªëi: 3 khung d√†i h∆°n ƒë·ªÉ c√¢n A4
        (MARGIN, MARGIN + 850 + 1050 + 2*GAP, 640, 900),  # 4Ô∏è‚É£ bottom-left (1:1.4)
        (MARGIN + 640 + GAP, MARGIN + 850 + 1050 + 2*GAP, 640, 900),  # 5Ô∏è‚É£ bottom-mid
        (MARGIN + 2*(640 + GAP), MARGIN + 850 + 1050 + 2*GAP, 640, 900),  # 6Ô∏è‚É£ bottom-right
    ],




        
    "layout_4": [  # 6 panels - 1 wide + 3 mid + 2 bottom
        (MARGIN, MARGIN, 2000, 850),  # 1Ô∏è‚É£ wide cinematic
        (MARGIN, MARGIN + 850 + GAP, 640, 980),  # 2Ô∏è‚É£ mid-left
        (MARGIN + 640 + GAP, MARGIN + 850 + GAP, 640, 980),  # 3Ô∏è‚É£ mid-center
        (MARGIN + 2*(640 + GAP), MARGIN + 850 + GAP, 640, 980),  # 4Ô∏è‚É£ mid-right
        (MARGIN, MARGIN + 850 + 980 + 2*GAP, 980, 980),  # 5Ô∏è‚É£ bottom-left
        (MARGIN + 980 + GAP, MARGIN + 850 + 980 + 2*GAP, 980, 980),  # 6Ô∏è‚É£ bottom-right
    ],
        
    "layout_6": [  # 3 panels - ultra cinematic top + 2 bottom deep
        (MARGIN, MARGIN, 2000, 1200),  # 1Ô∏è‚É£ top cinematic (3:2 - chi·∫øm ~40%)
        (MARGIN, MARGIN + 1200 + GAP, 990, 1650),  # 2Ô∏è‚É£ bottom-left (r·∫•t d√†i)
        (MARGIN + 980 + GAP, MARGIN + 1200 + GAP, 990, 1650),  # 3Ô∏è‚É£ bottom-right (r·∫•t d√†i)
    ],


    "layout_7": [  # 4 panels - artistic overlap & dynamic layout
        (MARGIN, MARGIN, 2000, 900),  # 1Ô∏è‚É£ top cinematic (16:9)
        (MARGIN, MARGIN + 920 + GAP, 980, 1020),  # 2Ô∏è‚É£ middle-left (vu√¥ng)
        (MARGIN + 970 + GAP, MARGIN + 940, 1020, 1020),  # 3Ô∏è‚É£ middle-right (tr·ªìi l√™n, ƒë√® nh·∫π khung 1)
        (MARGIN, MARGIN + 900 + 1090 + 2*GAP, 2000, 850),  # 4Ô∏è‚É£ bottom-wide (21:9, ph·ªß to√†n trang)
    ],


}

print("=" * 70)
print("‚úÖ LAYOUTS M·ªöI - D√ôNG K√çCH TH∆Ø·ªöC CHU·∫®N GEMINI")
print("=" * 70)
print(f"üìå T·∫•t c·∫£ {len(layouts)} layouts ƒë·ªÅu d√πng k√≠ch th∆∞·ªõc chu·∫©n")
print(f"üìå KH√îNG C·∫¶N RESIZE - Gemini sinh ƒë√∫ng k√≠ch th∆∞·ªõc ngay t·ª´ ƒë·∫ßu")
print("=" * 70)
for name, panels in layouts.items():
    print(f"   {name}: {len(panels)} panels")
    for i, (x, y, w, h) in enumerate(panels):
        ratio = f"{w}√ó{h}"
        print(f"      Panel {i+1}: {ratio}px")
print("=" * 70)


# üñºÔ∏è T·∫°o preview layouts
def create_layout_preview(layout_name, panels, save_dir="layout_previews"):
    """T·∫°o ·∫£nh preview cho layout"""
    os.makedirs(save_dir, exist_ok=True)
    
    img = Image.new("RGB", (PAGE_W, PAGE_H), "white")
    draw = ImageDraw.Draw(img)
    
    # V·∫Ω c√°c khung
    for i, (x, y, w, h) in enumerate(panels):
        # V·∫Ω vi·ªÅn khung
        draw.rectangle([x, y, x+w, y+h], outline="black", width=8)
        
        # V·∫Ω s·ªë th·ª© t·ª±
        center_x = x + w // 2
        center_y = y + h // 2
        draw.text((center_x, center_y), str(i+1), fill="red", anchor="mm", font_size=100)
    
    # L∆∞u ·∫£nh
    img_path = os.path.join(save_dir, f"{layout_name}.png")
    img.save(img_path)
    return img_path

# T·∫°o preview cho t·∫•t c·∫£ layouts
for name, panels in layouts.items():
    create_layout_preview(name, panels)

print("‚úÖ ƒê√£ t·∫°o preview cho t·∫•t c·∫£ layouts trong folder 'layout_previews'")



# üé≤ Nh·∫≠p s·ªë trang v√† random layouts
num_pages = int(input("üìñ Nh·∫≠p s·ªë trang truy·ªán mu·ªën t·∫°o: "))

# Random layouts cho t·∫•t c·∫£ c√°c trang
layout_names = list(layouts.keys())
selected_layouts = []

# T·∫°o t·∫•t c·∫£ c√°c trang truy·ªán
for i in range(num_pages):
    layout_name = random.choice(layout_names)
    selected_layouts.append({
        "page_num": i + 1,  # Trang 1, 2, 3...
        "layout_name": layout_name,
        "panels": layouts[layout_name]
    })

print(f"\n‚úÖ ƒê√£ ch·ªçn {len(selected_layouts)} trang truy·ªán:")
for page in selected_layouts:
    print(f"   Trang {page['page_num']}: {page['layout_name']} ({len(page['panels'])} khung)")

# L∆∞u c·∫•u tr√∫c layouts
with open("comic_structure.json", "w", encoding="utf-8") as f:
    json.dump(selected_layouts, f, indent=2, ensure_ascii=False)



# üìù Nh·∫≠p y√™u c·∫ßu truy·ªán
story_requirement = input("nh·∫≠p")

print(f"\n‚úÖ ƒê√£ nh·∫≠n y√™u c·∫ßu: {story_requirement}")


# ü§ñ Sinh k·ªãch b·∫£n v·ªõi Gemini
def generate_story_script(requirement, pages_info):
    """Sinh k·ªãch b·∫£n chi ti·∫øt cho t·ª´ng trang, t·ª´ng khung - KH√îNG C√ì DEMO PAGE"""
    
    prompt = f"""
You are a professional comic book scriptwriter who has worked for companies like Shonen Jump, Webtoon, and Marvel. You have the ability to build engaging stories, vivid characters, natural dialogue, clear conflicts, and logical climaxes. Create a detailed and cinematic comic script with a natural style, emotional depth, and suitable for the genre requested by the user.

====================
üîí CONSISTENT CONTEXT AND COHESION GUIDELINES (Based on Best Practices for Building Compelling, Inspirational, Coherent, and Cohesive Stories):
- Always maintain the main context of the story based on {requirement} (e.g., if it's about war, all pages must take place in war-related environments like battlefields, ruined villages, or refugee camps ‚Äì no jumping to modern or unrelated fictional settings without seamless integration).
- Ensure every element reinforces this context through setting descriptions, mood, and actions to create unity and avoid deviations in genre or theme.
- Build a cohesive narrative arc: Use a 3-act structure (Act 1: Setup with initial conflict and emotional stakes; Act 2: Confrontation with rising obstacles for character growth; Act 3: Resolution with inspirational transformation and message). Characters develop from introduction (establish initial emotional conflict and stakes), development (build tension and emotional growth via obstacles), climax (peak emotional moment with inspiration or transformation), to resolution (end with a profound message, leaving lasting emotional resonance).
- Draw from storytelling best practices: 
  - Cohesion: Every part (characters, plot, setting) serves a purpose in a unified whole; simplify elements to reduce complexity while maintaining emotional depth.
  - Structure: Start with a one-sentence storyline, expand to 3-act structure (setup, confrontation, resolution) for coherence; include specific, vivid events with emotional ups and downs.
  - Character Development: Make characters vivid, relatable with personal struggles, authentic motivations, backstories, and growth arcs that inspire empathy; include relations between characters for deeper links.
  - Plot: Use clear structure, consistent pacing, and tone for smooth transitions; foreshadow any shifts (e.g., flashbacks or visions) with subtle hints to avoid mismatches; add obstacles that build inspiration through empathy and positive change.
  - Inspiration: Cultivate empathy, show positive transformation amid challenges, and convey authentic, relatable messages; use wordless or reflective moments to engage readers profoundly.
  - Overall Coherence: Organize ideas logically, ensure vivid visuals and emotional hooks to absorb readers; if including non-core elements like visions, integrate them as part of character arcs (e.g., a war soldier's hallucination tied to motivation).

====================
üéØ STORY REQUIREMENT:
{requirement}

====================
üìò STORY STRUCTURE:
Total {len(pages_info)} pages

{chr(10).join([f'- Page {p["page_num"]}: {len(p["panels"])} panels' for p in pages_info])}

====================
üé® OUTPUT REQUIREMENTS (JSON FORMAT):
{{
  "title": "Story title (short, impactful, evocative)",
  "genre": "Genre (e.g.: action, fantasy, sci-fi, slice of life, adventure, drama, historical, romance, psychological, horror, comedy...)", 
  "tone": "Main emotional tone (e.g.: inspiring, dark, melancholic, humorous...)",
  "theme": "Philosophical theme or main message of the story (must be profound, tightly linked to the context and character arcs, e.g.: loss in war leading to hope and rebirth through ancestral inspiration)",
  "art_style": "Art style (e.g.: manga noir, modern webtoon, semi-realistic watercolor...)",
  "story_outline": "High-level 3-act summary (Act 1: Setup; Act 2: Confrontation with obstacles; Act 3: Resolution with transformation; keep concise but ensure coherence and inspiration)",

  "characters": [
    {{
      "name": "Character name",
      "role": "main / supporting / antagonist / mentor",
      "appearance": {{
        "age": "Age (e.g.: teen, young adult, middle-aged...)",
        "gender": "male/female/other",
        "height": "Height (e.g.: tall, average, short)",
        "build": "Build (e.g.: athletic, slim, muscular, petite...)",
        "hair": "Hair color and style in detail (e.g.: long silver hair in ponytail, spiky red hair...)",
        "eyes": "Eye color and features (e.g.: bright blue eyes, sharp golden eyes...)",
        "skin": "Skin tone (e.g.: pale, tan, dark...)",
        "clothing": "Clothing in detail (e.g.: black leather jacket with red scarf, school uniform...)",
        "distinctive_features": "Distinctive features (e.g.: scar on left cheek, always wears glasses, mechanical arm...)"
      }},
      "personality": "Personality (e.g.: brave but reckless, quiet and observant...; make it vivid and tied to their arc for emotional depth)",
      "backstory": "Brief backstory (e.g.: grew up in a war-torn village, lost family to conflict; link to context for cohesion)",
      "relations": "Relations to other characters (e.g.: brother to Main Character, rival to Antagonist; build emotional links)",
      "motivation": "Deep motivation or pain driving their actions (must link to the context, create emotional depth, e.g.: losing family in war fuels revenge or redemption; ensure it evolves for inspiration)"
    }}
  ],

  "pages": [
    {{
      "page_num": 1,
      "scene_description": "Opening scene - establish setting, tone, and first emotional hook (introduce main context, initial conflict, and foreshadow key elements for cohesion)",
      "mood": "Mood/atmosphere of the page (e.g.: tense, peaceful, action-packed...; must be consistent with overall context)",
      "panels": [
        {{
          "panel_num": 1,
          "dialogue": "Dialogue in Vietnamese (short, natural, evocative of emotions, reflecting inner thoughts)",
          "action": "Action taking place (tightly linked to context, character arc, and obstacles)",
          "shot_type": "Shot type (wide/establishing, medium, close-up, extreme close-up...)",
          "characters_in_panel": ["Character name 1", "Character name 2"],
          "basic_visual": "Short visual description (to be expanded later; include context details for cohesion and foreshadowing)"
        }}
      ]
    }},
    {{
      "page_num": 2,
      "scene_description": "Conflict rising - introduce dilemma or surprise element (build emotional tension and obstacles within the main context; foreshadow resolutions)",
      "mood": "...",
      "panels": [...]
    }}
  ]
}}

====================
‚öôÔ∏è GENRE-SPECIFIC GUIDELINES:

Customize plot progression, emotions, and action scenes based on the genre, but always maintain context consistency and build deeper emotions through character arcs, inspirational moments (e.g., reflection, sacrifice, realization), cohesive elements, and 3-act integration:

- **Action:** Include fight scenes, strong movements, violent sounds, close-ups of fists, weapons, speed, sweat, wounds, flashes, and determination.  
  ‚Üí Create ‚Äúmoment of impact‚Äù in some panels (e.g.: punch breaking through frame, exploding dust). Add emotion: Characters fight with inner pain, overcoming obstacles for inspirational growth.

- **Romance:** Slower pace, heavy internal emotions, authentic dialogue, eye contact, hand touches, or kisses ‚Äì tears, soft smiles, or separations.  
  ‚Üí Panels show ‚Äútension‚Äù between characters, soft lighting, close angles, open emotions. Add depth: Romantic conflicts tied to context (e.g.: love in wartime), with obstacles leading to transformation.

- **Drama / Slice of Life:** Focus on daily life, relationships, memories, growth journeys, quiet or poignant moments.  
  ‚Üí Panels with intimate layouts, natural lighting, environmental details. Add emotion: Reflective moments, inner changes via obstacles for inspiration.

- **Fantasy / Adventure:** Vast worlds, magic, mythical creatures, special weapons, fantastical battles, vibrant settings.  
  ‚Üí Add wide panels (establishing shots) to show world scale. Maintain consistency: Fantasy context doesn't mix with reality; foreshadow any shifts.

- **Horror / Psychological:** Gloomy atmosphere, tension, contrasting lights, distorted faces, bizarre behaviors, cold laughs.  
  ‚Üí Use light descriptions, sounds, and close angles for pressure. Add emotion: Inner fears linked to context, resolved through inspirational realization.

- **Comedy:** Fast pace, exaggerated expressions, humorous reactions, ironic situations.  
  ‚Üí Panels with sudden transitions, funny sounds (‚ÄúBOING!‚Äù, ‚Äú!?!‚Äù). Add depth: Humor masking true emotions, with obstacles for growth.

- **Sci-Fi:** Focus on technology, future, AI, space, or robots.  
  ‚Üí Visuals with neon lights, machinery, holograms, futuristic cities. Maintain consistency: Future context doesn't mix with present; build inspiration through tech-driven transformations.

====================
‚ö†Ô∏è STRICT RULES:

1. **PANEL COUNTS**
{chr(10).join([f'   - PAGE {p["page_num"]}: EXACTLY {len(p["panels"])} panels' for p in pages_info])}

2. **CHARACTERS - EXTREMELY DETAILED DESCRIPTIONS**
   - Each character needs extremely specific appearance descriptions.
   - Include: age, gender, height, build, hair (color + style), eyes (color), skin, clothing, distinctive_features.
   - Detailed enough for AI to draw the character accurately.
   - Consistent throughout (same character = same description) and linked to context (e.g.: clothing suitable for war); tie to backstory and relations.

3. **PLOT**
   - Logical rhythm (introduction ‚Üí development ‚Üí climax ‚Üí resolution) following 3-act structure.
   - Each page has unique mood and atmosphere but consistent with overall context.
   - Dialogue natural, short, and deeply emotional; foreshadow key elements.

4. **PANELS**
   - Each panel has: dialogue, action, shot_type, characters_in_panel, basic_visual.
   - Diverse shot types (wide, medium, close-up...).
   - Basic visual short but reinforces context, foreshadowing, and emotional arcs.

5. **OUTPUT**
   - Return only valid JSON.
   - NO explanations or other text.
   - NO markdown code blocks.

6. **LANGUAGE**
    - All dialogue must be in Vietnamese.
"""



    
    response = text_model.generate_content(prompt)
    
    # Parse JSON t·ª´ response
    try:
        # Lo·∫°i b·ªè markdown code block n·∫øu c√≥
        text = response.text.strip()
        if text.startswith("```json"):
            text = text[7:]
        if text.startswith("```"):
            text = text[3:]
        if text.endswith("```"):
            text = text[:-3]
        
        script = json.loads(text.strip())
        return script
    except json.JSONDecodeError as e:
        print(f"‚ùå L·ªói parse JSON: {e}")
        print(f"Response: {response.text}")
        return None

print("ü§ñ ƒêang sinh k·ªãch b·∫£n v·ªõi Gemini AI...")
story_script = generate_story_script(story_requirement, selected_layouts)

if story_script:
    # ‚úÖ VALIDATION: Ki·ªÉm tra v√† s·ª≠a s·ªë l∆∞·ª£ng panels
    print("\nüîç Ki·ªÉm tra s·ªë l∆∞·ª£ng panels...")
    for i, page in enumerate(story_script['pages']):
        expected_panels = len(selected_layouts[i]['panels'])
        actual_panels = len(page['panels'])
        
        if actual_panels != expected_panels:
            print(f"   ‚ö†Ô∏è Trang {page['page_num']}: C√≥ {actual_panels} panels, c·∫ßn {expected_panels}")
            
            if actual_panels > expected_panels:
                # C·∫Øt b·ªõt panels th·ª´a
                page['panels'] = page['panels'][:expected_panels]
                print(f"      ‚Üí ƒê√£ c·∫Øt b·ªõt xu·ªëng {expected_panels} panels")
            else:
                # Th√™m panels thi·∫øu (duplicate panel cu·ªëi)
                while len(page['panels']) < expected_panels:
                    last_panel = page['panels'][-1].copy()
                    last_panel['panel_num'] = len(page['panels']) + 1
                    page['panels'].append(last_panel)
                print(f"      ‚Üí ƒê√£ th√™m panels l√™n {expected_panels}")
        else:
            print(f"   ‚úÖ Trang {page['page_num']}: {actual_panels} panels - ƒê√∫ng!")
    
    # L∆∞u k·ªãch b·∫£n ƒë√£ s·ª≠a
    with open("story_script.json", "w", encoding="utf-8") as f:
        json.dump(story_script, f, indent=2, ensure_ascii=False)
    
    print(f"\n‚úÖ ƒê√£ sinh k·ªãch b·∫£n truy·ªán: {story_script['title']}")
    print(f"   Phong c√°ch: {story_script['art_style']}")
    print(f"   S·ªë nh√¢n v·∫≠t: {len(story_script['characters'])}")
    print(f"   S·ªë trang: {len(story_script['pages'])}")
else:
    print("‚ùå Kh√¥ng th·ªÉ sinh k·ªãch b·∫£n. Vui l√≤ng th·ª≠ l·∫°i.")




# üé® H√†m sinh prompt CHI TI·∫æT cho t·ª´ng panel
def generate_detailed_prompts(story_script):
    """
    G·ªçi Gemini ƒë·ªÉ sinh prompt C·ª∞C K·ª≤ CHI TI·∫æT cho t·ª´ng panel
    
    - M√¥ t·∫£ nh√¢n v·∫≠t CH√çNH X√ÅC theo appearance ƒë√£ ƒë·ªãnh
    - Background v√† setting c·ª• th·ªÉ
    - Lighting, mood, camera angle
    - ƒê·∫£m b·∫£o consistency gi·ªØa c√°c panels
    
    Returns:
        story_script v·ªõi th√™m tr∆∞·ªùng "detailed_prompt" cho m·ªói panel
    """
    
    print("\nüé® ƒêang sinh prompt chi ti·∫øt cho t·ª´ng panel...")
    print("=" * 70)
    
    # Chu·∫©n b·ªã th√¥ng tin nh√¢n v·∫≠t C·ª∞C K·ª≤ CHI TI·∫æT
    character_profiles = []
    for char in story_script['characters']:
        app = char['appearance']
        profile = f"""
CHARACTER: {char['name']} ({char['role']})
Physical Description (MUST BE EXACT IN ALL PANELS):
- Age: {app['age']}, Gender: {app['gender']}
- Height: {app['height']}, Build: {app['build']}
- Hair: {app['hair']} (EXACT same style in all panels)
- Eyes: {app['eyes']} (EXACT same color in all panels)
- Skin: {app['skin']}
- Clothing: {app['clothing']} (CONSISTENT outfit)
- Distinctive Features: {app['distinctive_features']}
Personality: {char['personality']}
"""
        character_profiles.append(profile)
    
    character_reference = "\n".join(character_profiles)
    
    # Duy·ªát qua t·ª´ng trang, t·ª´ng panel
    for page in story_script['pages']:
        page_num = page['page_num']
        print(f"\nüìÑ Trang {page_num}: ƒêang x·ª≠ l√Ω {len(page['panels'])} panels...")
        
        for panel in page['panels']:
            panel_num = panel['panel_num']
            
            # T·∫°o prompt chi ti·∫øt cho panel n√†y
            prompt = f"""
You are an expert comic book art director and prompt engineer. Your job is to create EXTREMELY DETAILED image generation prompts for a comic panel.

====================
üîí CONSISTENT CONTEXT AND COHESION GUIDELINES:
- Always maintain the main story context in every description (e.g.: if war-themed, include details like ruined battlefields, smoke, or war sounds ‚Äì no adding unrelated elements like modern tech unless sci-fi; integrate any visions/flashbacks with visual cues like faded edges or tied to character expressions).
- Reinforce emotions through visuals: Add details evoking deep emotions (e.g.: pained expressions, dim lighting reflecting inner turmoil, or inspirational moments tied to character arcs and obstacles).
- Ensure cohesion with 3-act arc: Visuals should support setup, confrontation, or resolution phases.

====================
üìö STORY CONTEXT:
Title: {story_script['title']}
Genre: {story_script['genre']}
Art Style: {story_script['art_style']}
Tone: {story_script['tone']}

====================
üë• CHARACTER REFERENCE (MUST MAINTAIN EXACT CONSISTENCY):
{character_reference}

====================
üìÑ PAGE {page_num} CONTEXT:
Scene: {page['scene_description']} (keep consistent with overall story context, including foreshadowing for coherence)
Mood: {page['mood']} (add deep emotional details, linked to theme and inspirational arc)

====================
üé¨ THIS PANEL ({panel_num}):
Shot Type: {panel['shot_type']}
Action: {panel['action']} (tightly linked to context, emotional arc, and obstacles)
Characters: {', '.join(panel['characters_in_panel'])}
Basic Visual: {panel['basic_visual']} (expand to reinforce context, cohesion, and foreshadowing)

====================
‚úçÔ∏è YOUR TASK:
Create an EXTREMELY DETAILED English prompt for Gemini image generation that includes:

1. **Art Style & Medium**: Specify the exact art style from the story (manga, webtoon, etc.) and adjust for context (e.g.: gritty realism for war, with inspirational highlights).

2. **Characters** (IF ANY IN SCENE):
   - For EACH character in the panel, use their EXACT physical description from the character reference above.
   - Copy the appearance details WORD FOR WORD to ensure consistency.
   - Include: hair, eyes, height, build, clothing, distinctive features.
   - Example: "tall athletic man with spiky red hair, bright blue eyes, wearing black leather jacket with red scarf, scar on left cheek".
   - Add emotional expressions: Describe poses and faces to reflect inner emotions, backstory relations, and arc progress (e.g.: eyes teary from grief in war, showing inspirational resolve).

3. **Composition & Camera**:
   - Shot type: {panel['shot_type']}.
   - Camera angle (eye-level, high angle, low angle, dutch angle, etc.) (choose to heighten emotional tension or inspiration, e.g.: low angle for heroic transformation).
   - Framing and positioning of elements for cohesion.

4. **Background & Setting**:
   - Specific location details (must be consistent with story context, describe in detail for cohesion, e.g.: battlefield with tank wreckage, bombing rain; integrate any shifts smoothly).
   - Environmental elements that tie to theme.
   - Depth and perspective.

5. **Lighting & Atmosphere**:
   - Light source and direction.
   - Shadows and highlights.
   - Color temperature (warm/cool).
   - Mood: {page['mood']} (add effects evoking emotions and inspiration, e.g.: red-tinted light for war tension, golden glow for hopeful resolution).

6. **Action & Motion**:
   - What's happening: {panel['action']}.
   - Motion lines or effects if needed (add for emotional impact, e.g.: blur for sacrificial moment or obstacle confrontation).
   - Character poses and expressions (focus on inner emotions, relations, and arc development).

7. **Technical Requirements**:
   - High quality comic book illustration.
   - Clean linework.
   - Professional composition.
   - NO TEXT, NO DIALOGUE, NO SPEECH BUBBLES in the image (text will be added separately).
   - Add: High emotional impact, visual storytelling that conveys theme, consistency, and inspirational elements.

====================
‚ö†Ô∏è CRITICAL RULES:
- Use EXACT character descriptions from the reference (copy-paste their appearance details).
- Maintain consistency with previous panels (same characters = same appearance) and overall context; foreshadow shifts.
- Be specific about every visual element to create deeper emotions and cohesion.
- Write in clear English.
- Do NOT include any text/dialogue in the image description.
- Focus on visual storytelling and evoking emotions through imagery.

====================
OUTPUT FORMAT (plain text, no JSON)
Just output the detailed prompt in English, nothing else.".


6. **LANGUAGE**
    - All dialogue must be in Vietnamese.
"""
            
            # G·ªçi Gemini
            try:
                response = text_model.generate_content(prompt)
                detailed_prompt = response.text.strip()
                
                # Th√™m detailed_prompt v√†o panel
                panel['detailed_prompt'] = detailed_prompt
                
                print(f"   ‚úÖ Panel {panel_num}: {len(detailed_prompt)} k√Ω t·ª±")
                
                # Delay nh·ªè ƒë·ªÉ tr√°nh rate limit
                time.sleep(0.5)
                
            except Exception as e:
                print(f"   ‚ùå Panel {panel_num} l·ªói: {e}")
                # Fallback: d√πng basic visual
                panel['detailed_prompt'] = f"{story_script['art_style']} comic art. {panel['basic_visual']}. Characters: {', '.join(panel['characters_in_panel'])}. {panel['shot_type']} shot. NO TEXT in image."
    
    print("\n" + "=" * 70)
    print("‚úÖ Ho√†n th√†nh sinh prompt chi ti·∫øt!")
    print("=" * 70)
    
    return story_script


print("‚úÖ ƒê√£ ƒë·ªãnh nghƒ©a h√†m generate_detailed_prompts")
print("üìå S·∫Ω g·ªçi Gemini l·∫ßn 2 sau khi c√≥ story_script")
print("üìå T·∫°o prompt C·ª∞C K·ª≤ chi ti·∫øt cho t·ª´ng panel")




# üîÑ G·ªçi h√†m sinh prompt chi ti·∫øt
if story_script:
    print("\n" + "=" * 70)
    print("üé® B∆Ø·ªöC 3.5: SINH PROMPT CHI TI·∫æT CHO T·ª™NG PANEL")
    print("=" * 70)
    
    story_script = generate_detailed_prompts(story_script)
    
    # L∆∞u l·∫°i story_script ƒë√£ c√≥ detailed prompts
    with open("story_script_with_prompts.json", "w", encoding="utf-8") as f:
        json.dump(story_script, f, indent=2, ensure_ascii=False)
    
    print("\n‚úÖ ƒê√£ sinh xong prompt chi ti·∫øt cho T·∫§T C·∫¢ panels!")
    print(f"   ƒê√£ l∆∞u: story_script_with_prompts.json")
    
    # Hi·ªÉn th·ªã sample
    print("\nüìù Sample prompt chi ti·∫øt (Panel 1, Trang 1):")
    print("=" * 70)
    sample_prompt = story_script['pages'][0]['panels'][0]['detailed_prompt']
    print(sample_prompt[:500] + "...")
    print("=" * 70)
else:
    print("‚ùå Ch∆∞a c√≥ story_script. Vui l√≤ng ch·∫°y cell sinh k·ªãch b·∫£n tr∆∞·ªõc.")




# üîç Test: Ki·ªÉm tra s·ªë panels
if 'story_script' in locals() and 'selected_layouts' in locals():
    print("=" * 70)
    print("üîç KI·ªÇM TRA S·ªê L∆Ø·ª¢NG PANELS")
    print("=" * 70)
    
    all_match = True
    for i, page in enumerate(story_script['pages']):
        layout_panels = len(selected_layouts[i]['panels'])
        script_panels = len(page['panels'])
        
        status = "‚úÖ" if layout_panels == script_panels else "‚ùå"
        print(f"{status} Trang {page['page_num']}: Layout c√≥ {layout_panels} khung, Script c√≥ {script_panels} panels")
        
        if layout_panels != script_panels:
            all_match = False
    
    print("=" * 70)
    if all_match:
        print("‚úÖ T·∫§T C·∫¢ ƒê·ªÄU KH·ªöP! S·∫µn s√†ng t·∫°o ·∫£nh!")
    else:
        print("‚ö†Ô∏è C√ì TRANG KH√îNG KH·ªöP!")
        print("üìå H√£y ch·∫°y l·∫°i cell sinh k·ªãch b·∫£n ƒë·ªÉ t·ª± ƒë·ªông s·ª≠a")
    print("=" * 70)
else:
    print("‚ùå Ch∆∞a c√≥ story_script ho·∫∑c selected_layouts")



# üé® H√†m t·∫°o ·∫£nh ƒê√öNG K√çCH TH∆Ø·ªöC v·ªõi Gemini 2.5 Flash Image
def generate_image_with_gemini(prompt, width, height):
    """
    T·∫°o ·∫£nh v·ªõi Gemini 2.5 Flash Image - ƒê√öNG K√çCH TH∆Ø·ªöC NGAY T·ª™ ƒê·∫¶U
    
    ‚ö†Ô∏è KH√îNG RESIZE - Gemini ph·∫£i sinh ƒë√∫ng k√≠ch th∆∞·ªõc
    
    Args:
        prompt: M√¥ t·∫£ ·∫£nh (ti·∫øng Anh)
        width: Chi·ªÅu r·ªông CH√çNH X√ÅC (px)
        height: Chi·ªÅu cao CH√çNH X√ÅC (px)
    
    Returns:
        PIL.Image v·ªõi k√≠ch th∆∞·ªõc CH√çNH X√ÅC width x height
    """
    print(f"   [Gemini] Y√™u c·∫ßu ·∫£nh {width}x{height}px")
    print(f"   Prompt: {prompt[:80]}...")
    
    try:
        # T·∫°o prompt Y√äU C·∫¶U ƒê√öNG K√çCH TH∆Ø·ªöC
        aspect_ratio = width / height
        
        # X√°c ƒë·ªãnh orientation
        if aspect_ratio > 1.5:
            orientation = "wide landscape"
        elif aspect_ratio > 1.1:
            orientation = "landscape"
        elif aspect_ratio > 0.9:
            orientation = "square"
        elif aspect_ratio > 0.6:
            orientation = "portrait"
        else:
            orientation = "tall portrait"
        
        full_prompt = f"""Create a {orientation} comic panel image.

CRITICAL REQUIREMENTS:
- Exact dimensions: {width} x {height} pixels
- Aspect ratio: {aspect_ratio:.2f}:1
- {orientation.upper()} FORMAT ONLY

Content:
{prompt}

Style:
- Professional comic book artwork
- Clean composition
- High quality illustration
- Suitable for comic panel
- NO TEXT OR DIALOGUE IN IMAGE (text will be added separately)

Output must be EXACTLY {width}x{height} pixels."""
        
        # G·ªçi image_model
        if image_model:
            try:
                response = image_model.generate_content([full_prompt])
                
                if hasattr(response, 'candidates') and len(response.candidates) > 0:
                    for part in response.candidates[0].content.parts:
                        if hasattr(part, 'inline_data') and part.inline_data:
                            image_bytes = part.inline_data.data
                            img = Image.open(io.BytesIO(image_bytes))
                            
                            original_size = img.size
                            print(f"   üìê Gemini sinh: {original_size[0]}x{original_size[1]}px")
                            
                            # ‚ö†Ô∏è CH·ªà RESIZE N·∫æU SAI K√çCH TH∆Ø·ªöC
                            if img.size != (width, height):
                                print(f"   ‚ö†Ô∏è SAI K√çCH TH∆Ø·ªöC! ƒêang resize {original_size} ‚Üí {width}x{height}")
                                img = img.resize((width, height), Image.Resampling.LANCZOS)
                            else:
                                print(f"   ‚úÖ ƒê√öNG K√çCH TH∆Ø·ªöC!")
                            
                            return img
            except Exception as e:
                print(f"   ‚ö†Ô∏è L·ªói SDK: {e}")
        
        # G·ªçi REST API
        print(f"   ‚Üí G·ªçi REST API...")
        
        api_url = f"https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-image:generateContent?key={GEMINI_API_KEY}"
        
        payload = {
            "contents": [{
                "parts": [{
                    "text": full_prompt
                }]
            }],
            "generationConfig": {
                "temperature": 0.8,
                "topP": 0.95,
                "topK": 40
            }
        }
        
        response = requests.post(api_url, json=payload, timeout=90)
        
        if response.status_code == 200:
            result = response.json()
            
            if 'candidates' in result:
                for candidate in result['candidates']:
                    if 'content' in candidate:
                        for part in candidate['content'].get('parts', []):
                            if 'inlineData' in part:
                                image_data = base64.b64decode(part['inlineData']['data'])
                                img = Image.open(io.BytesIO(image_data))
                                
                                original_size = img.size
                                print(f"   üìê Gemini sinh: {original_size[0]}x{original_size[1]}px")
                                
                                # ‚ö†Ô∏è CH·ªà RESIZE N·∫æU SAI
                                if img.size != (width, height):
                                    print(f"   ‚ö†Ô∏è SAI K√çCH TH∆Ø·ªöC! Resize {original_size} ‚Üí {width}x{height}")
                                    img = img.resize((width, height), Image.Resampling.LANCZOS)
                                else:
                                    print(f"   ‚úÖ ƒê√öNG K√çCH TH∆Ø·ªöC!")
                                
                                return img
        
        raise Exception(f"Kh√¥ng t√¨m th·∫•y ·∫£nh. Status: {response.status_code}")
        
    except Exception as e:
        raise Exception(f"L·ªói t·∫°o ·∫£nh: {str(e)}")


print("=" * 70)
print("‚úÖ ƒê√£ c·∫•u h√¨nh h√†m t·∫°o ·∫£nh ƒê√öNG K√çCH TH∆Ø·ªöC")
print("=" * 70)
print("üìå Gemini s·∫Ω nh·∫≠n y√™u c·∫ßu CH√çNH X√ÅC v·ªÅ k√≠ch th∆∞·ªõc")
print("üìå N·∫øu Gemini sinh sai size ‚Üí s·∫Ω c·∫£nh b√°o v√† resize")
print("üìå L·ªùi tho·∫°i s·∫Ω ƒë∆∞·ª£c th√™m SAU v·ªõi font ƒê·∫∏P")
print("=" * 70)





# üí¨ H√†m v·∫Ω l·ªùi tho·∫°i ƒê·∫∏P cho comic
def draw_dialogue_bubble(img, dialogue_text, position="top"):
    """
    V·∫Ω l·ªùi tho·∫°i bubble ƒê·∫∏P l√™n ·∫£nh panel
    
    Args:
        img: PIL Image object
        dialogue_text: L·ªùi tho·∫°i ti·∫øng Vi·ªát
        position: "top" ho·∫∑c "bottom"
    
    Returns:
        PIL Image v·ªõi bubble ƒë√£ v·∫Ω
    """
    from PIL import ImageDraw, ImageFont
    
    # T·∫°o copy ƒë·ªÉ kh√¥ng l√†m h·ªèng ·∫£nh g·ªëc
    img_copy = img.copy()
    draw = ImageDraw.Draw(img_copy, 'RGBA')
    w, h = img.size
    
    # T√≠nh to√°n k√≠ch th∆∞·ªõc bubble
    padding = 20
    bubble_width = w - padding * 2
    
    # Font size t·ª± ƒë·ªông theo k√≠ch th∆∞·ªõc panel
    font_size = max(28, min(56, int(w / 18)))
    
    # Th·ª≠ load font ƒë·∫πp (Windows fonts)
    try:
        font = ImageFont.truetype("C:\Windows\Fonts\TIMESBD.TTF", font_size)
    except:
        try:
            font = ImageFont.truetype("C:\Windows\Fonts\TIMESBD.TTF", font_size)
        except:
            try:
                font = ImageFont.truetype(r"C:\Windows\Fonts\TIMESBD.TTF", font_size)
            except:
                print(f"   ‚ö†Ô∏è Kh√¥ng load ƒë∆∞·ª£c font, d√πng default")
                font = ImageFont.load_default()
    
    # Wrap text th√¥ng minh
    words = dialogue_text.split()
    lines = []
    current_line = ""
    max_line_width = bubble_width - padding * 2
    
    for word in words:
        test_line = current_line + word + " "
        try:
            bbox = draw.textbbox((0, 0), test_line, font=font)
            line_width = bbox[2] - bbox[0]
        except:
            # Fallback n·∫øu textbbox kh√¥ng ho·∫°t ƒë·ªông
            line_width = len(test_line) * (font_size // 2)
        
        if line_width <= max_line_width:
            current_line = test_line
        else:
            if current_line:
                lines.append(current_line.strip())
            current_line = word + " "
    
    if current_line:
        lines.append(current_line.strip())
    
    # Gi·ªõi h·∫°n 3 d√≤ng
    lines = lines[:3]
    
    # T√≠nh to√°n k√≠ch th∆∞·ªõc bubble
    line_height = font_size + 12
    bubble_height = len(lines) * line_height + padding * 2 + 10
    
    # V·ªã tr√≠ bubble
    if position == "top":
        bubble_y = padding
    else:  # bottom
        bubble_y = h - bubble_height - padding
    
    bubble_x = padding
    
    # V·∫Ω SHADOW cho bubble
    shadow_offset = 5
    draw.rounded_rectangle(
        [bubble_x + shadow_offset, bubble_y + shadow_offset, 
         bubble_x + bubble_width + shadow_offset, bubble_y + bubble_height + shadow_offset],
        radius=20,
        fill=(0, 0, 0, 120)  # B√≥ng ƒëen m·ªù
    )
    
    # V·∫Ω BUBBLE ch√≠nh (tr·∫Øng)
    draw.rounded_rectangle(
        [bubble_x, bubble_y, bubble_x + bubble_width, bubble_y + bubble_height],
        radius=20,
        fill=(255, 255, 255, 250),  # Tr·∫Øng g·∫ßn ƒë·ª•c
        outline=(0, 0, 0, 255),  # Vi·ªÅn ƒëen
        width=4
    )
    
    # V·∫Ω TEXT
    text_y = bubble_y + padding + 5
    for line in lines:
        # T√≠nh to√°n ƒë·ªÉ CENTER text
        try:
            bbox = draw.textbbox((0, 0), line, font=font)
            text_width = bbox[2] - bbox[0]
        except:
            text_width = len(line) * (font_size // 2)
        
        text_x = bubble_x + (bubble_width - text_width) // 2
        
        # V·∫Ω TEXT SHADOW (nh·∫°t)
        draw.text(
            (text_x + 2, text_y + 2),
            line,
            fill=(120, 120, 120, 200),
            font=font
        )
        
        # V·∫Ω TEXT ch√≠nh (ƒëen ƒë·∫≠m)
        draw.text(
            (text_x, text_y),
            line,
            fill=(0, 0, 0, 255),
            font=font
        )
        
        text_y += line_height
    
    return img_copy


print("‚úÖ ƒê√£ ƒë·ªãnh nghƒ©a h√†m v·∫Ω l·ªùi tho·∫°i ƒê·∫∏P")
print("üìå Font l·ªõn t·ª± ƒë·ªông theo k√≠ch th∆∞·ªõc panel")
print("üìå Bubble tr√≤n v·ªõi shadow ƒë·∫πp")
print("üìå Text ƒë∆∞·ª£c cƒÉn gi·ªØa v√† wrap th√¥ng minh")



# üß™ TEST HO√ÄN CH·ªàNH - T·∫°o ·∫£nh + L·ªùi tho·∫°i ƒê·∫∏P
print("üß™ TEST: T·∫°o ·∫£nh 620x520px v·ªõi l·ªùi tho·∫°i ƒê·∫∏P")
print("=" * 70)

test_prompt = "A cute anime girl with blue hair smiling happily in a sunny park, manga art style, detailed illustration"
test_dialogue = "Ch√†o b·∫°n! H√¥m nay tr·ªùi ƒë·∫πp qu√° nh·ªâ?"

try:
    # 1. T·∫†O ·∫¢NH
    print("\nüì∏ B∆∞·ªõc 1: T·∫°o ·∫£nh...")
    test_image = generate_image_with_gemini(test_prompt, 620, 520)
    
    print(f"\n‚úÖ ·∫¢nh ƒë√£ t·∫°o!")
    print(f"   K√≠ch th∆∞·ªõc: {test_image.size}")
    
    # Ki·ªÉm tra xem c√≥ b·ªã c·∫Øt kh√¥ng
    if test_image.size == (620, 520):
        print(f"   ‚úÖ ƒê√öNG K√çCH TH∆Ø·ªöC - KH√îNG B·ªä C·∫ÆT!")
    else:
        print(f"   ‚ö†Ô∏è SAI K√çCH TH∆Ø·ªöC - Gemini sinh ra {test_image.size}")
    
    # 2. TH√äM L·ªúI THO·∫†I ƒê·∫∏P
    print(f"\nüí¨ B∆∞·ªõc 2: Th√™m l·ªùi tho·∫°i...")
    print(f"   N·ªôi dung: '{test_dialogue}'")
    test_image_with_dialogue = draw_dialogue_bubble(test_image.copy(), test_dialogue, "top")
    
    # 3. HI·ªÇN TH·ªä V√Ä L∆ØU
    print(f"\nüñºÔ∏è K·∫øt qu·∫£:")
    display(test_image_with_dialogue)
    
    test_image_with_dialogue.save("test_final_620x520.png", quality=100)
    print(f"\n‚úÖ HO√ÄN TH√ÄNH!")
    print(f"   ƒê√£ l∆∞u: test_final_620x520.png")
    print(f"   K√≠ch th∆∞·ªõc: {test_image_with_dialogue.size}")
    print(f"   L·ªùi tho·∫°i: Font ƒê·∫∏P, bubble tr√≤n, shadow")
    
except Exception as e:
    print(f"\n‚ùå L·ªñI: {str(e)[:300]}...")



# ‚≠ê B·ªé QUA B∆Ø·ªöC T·∫†O DEMO - TRANG 1 S·∫º L√ÄM REFERENCE
print("=" * 70)
print("‚≠ê LOGIC M·ªöI: KH√îNG C·∫¶N DEMO IMAGES")
print("=" * 70)
print("üìå Trang 1 (8 khung) s·∫Ω gi·ªõi thi·ªáu nh√¢n v·∫≠t chi ti·∫øt")
print("üìå C√°c trang sau s·ª≠ d·ª•ng m√¥ t·∫£ t·ª´ trang 1 l√†m reference")
print("üìå ƒê·∫£m b·∫£o nh√¢n v·∫≠t NH·∫§T QU√ÅN qua to√†n b·ªô truy·ªán")
print("=" * 70)



# üéØ T·∫°o ·∫£nh cho t·ª´ng panel v·ªõi DETAILED PROMPT
def create_panel_images_v2(story_script, selected_layouts):
    """
    T·∫°o ·∫£nh cho t·ª´ng panel - S·ª¨ D·ª§NG DETAILED PROMPT ƒê√É SINH
    
    ‚≠ê LOGIC M·ªöI:
    - Kh√¥ng c·∫ßn demo page
    - M·ªói panel d√πng detailed_prompt ƒë√£ ƒë∆∞·ª£c Gemini t·∫°o
    - Detailed prompt ƒë√£ bao g·ªìm character consistency
    """
    panel_images = {}
    os.makedirs("panel_images", exist_ok=True)
    
    for i, page_data in enumerate(story_script['pages']):
        page_num = page_data['page_num']
        layout_info = selected_layouts[i]
        
        # ‚ö†Ô∏è KI·ªÇM TRA: S·ªë panel trong script vs layout
        num_panels_in_layout = len(layout_info['panels'])
        num_panels_in_script = len(page_data['panels'])
        
        if num_panels_in_script > num_panels_in_layout:
            print(f"\n‚ö†Ô∏è C·∫¢NH B√ÅO: Trang {page_num} c√≥ {num_panels_in_script} panels trong script")
            print(f"   nh∆∞ng layout ch·ªâ c√≥ {num_panels_in_layout} khung!")
            print(f"   ‚Üí Ch·ªâ t·∫°o {num_panels_in_layout} panels ƒë·∫ßu ti√™n")
            # C·∫Øt b·ªõt panels trong script ƒë·ªÉ kh·ªõp v·ªõi layout
            page_data['panels'] = page_data['panels'][:num_panels_in_layout]
        
        print(f"\nüìÑ Trang {page_num}: T·∫°o {len(page_data['panels'])} panels...")
        
        page_panels = []
        
        for j, panel_data in enumerate(page_data['panels']):
            panel_num = panel_data['panel_num']
            
            # L·∫•y k√≠ch th∆∞·ªõc CH√çNH X√ÅC t·ª´ layout
            x, y, w, h = layout_info['panels'][j]
            aspect_ratio = w / h 
            print(f"\n   üé® Panel {panel_num}:")
            print(f"      K√≠ch th∆∞·ªõc: {w}x{h}px ({aspect_ratio})")
            
            # ‚≠ê S·ª¨ D·ª§NG DETAILED PROMPT ƒê√É SINH
            if 'detailed_prompt' in panel_data:
                panel_prompt = panel_data['detailed_prompt']
                print(f"      ‚úÖ S·ª≠ d·ª•ng detailed prompt ({len(panel_prompt)} chars)")
            else:
                # Fallback n·∫øu kh√¥ng c√≥ detailed_prompt
                print(f"      ‚ö†Ô∏è Kh√¥ng c√≥ detailed_prompt, d√πng basic visual")
                panel_prompt = f"{story_script['art_style']} comic art. {panel_data.get('basic_visual', '')}. {panel_data.get('shot_type', 'medium')} shot. NO TEXT in image."
            
            # T·∫†O ·∫¢NH v·ªõi k√≠ch th∆∞·ªõc CH√çNH X√ÅC
            try:
                panel_img = generate_image_with_gemini(panel_prompt, w, h)
                
                # Ki·ªÉm tra k√≠ch th∆∞·ªõc
                actual_size = panel_img.size
                if actual_size != (w, h):
                    print(f"      ‚ö†Ô∏è C·∫¢NH B√ÅO: ·∫¢nh sinh ra {actual_size} kh√°c y√™u c·∫ßu {w}x{h}")
                else:
                    print(f"      ‚úÖ K√≠ch th∆∞·ªõc CH√çNH X√ÅC!")
                
                # TH√äM L·ªúI THO·∫†I ƒê·∫∏P (n·∫øu c√≥)
                if panel_data.get('dialogue'):
                    dialogue_text = panel_data['dialogue']
                    print(f"      üí¨ Th√™m l·ªùi tho·∫°i: {dialogue_text[:40]}...")
                    
                    # V·∫Ω bubble l·ªùi tho·∫°i ƒê·∫∏P
                    panel_img = draw_dialogue_bubble(panel_img, dialogue_text, position="top")
                
                # L∆ØU ·∫¢NH
                panel_path = f"panel_images/page_{page_num:02d}_panel_{panel_num:02d}.png"
                panel_img.save(panel_path, quality=100)  # Quality 100 - KH√îNG N√âN
                
                page_panels.append({
                    "panel_num": panel_num,
                    "image": panel_img,
                    "path": panel_path,
                    "position": (x, y, w, h)
                })
                
                print(f"      ‚úÖ ƒê√£ l∆∞u: {panel_path}")
                
            except Exception as e:
                print(f"      ‚ùå L·ªñI t·∫°o ·∫£nh: {str(e)[:200]}")
                # T·∫°o ·∫£nh placeholder
                panel_img = Image.new("RGB", (w, h), "lightgray")
                draw = ImageDraw.Draw(panel_img)
                draw.text((w//2, h//2), f"Error\nPanel {panel_num}", fill="red", anchor="mm")
                
                panel_path = f"panel_images/page_{page_num:02d}_panel_{panel_num:02d}_ERROR.png"
                panel_img.save(panel_path)
                
                page_panels.append({
                    "panel_num": panel_num,
                    "image": panel_img,
                    "path": panel_path,
                    "position": (x, y, w, h)
                })
        
        panel_images[page_num] = page_panels
        print(f"\n   ‚úÖ Ho√†n th√†nh trang {page_num}")
    
    return panel_images


print("‚úÖ ƒê√£ ƒë·ªãnh nghƒ©a create_panel_images_v2")
print("üìå S·ª≠ d·ª•ng detailed_prompt cho m·ªói panel")
print("üìå Kh√¥ng c·∫ßn demo page n·ªØa")



# üéØ H√†m v·∫Ω l·ªùi tho·∫°i ƒê·∫∏P cho comic
def draw_dialogue_bubble(img, dialogue_text, position="top"):
    """
    V·∫Ω l·ªùi tho·∫°i bubble ƒê·∫∏P l√™n ·∫£nh panel
    
    Args:
        img: PIL Image object
        dialogue_text: L·ªùi tho·∫°i ti·∫øng Vi·ªát
        position: "top" ho·∫∑c "bottom"
    """
    from PIL import ImageDraw, ImageFont
    
    draw = ImageDraw.Draw(img, 'RGBA')
    w, h = img.size
    
    # T√≠nh to√°n k√≠ch th∆∞·ªõc bubble
    padding = 20
    bubble_width = w - padding * 2
    
    # Font size t·ª± ƒë·ªông theo k√≠ch th∆∞·ªõc panel
    font_size = max(24, min(48, int(w / 20)))
    
    # Th·ª≠ load font ƒë·∫πp, fallback v·ªÅ default
    try:
        # Windows fonts
        font = ImageFont.truetype(r"C:\Windows\Fonts\TIMESBD.TTF", font_size)
        font_bold = ImageFont.truetype(r"C:\Windows\Fonts\TIMESBD.TTF", font_size + 4)
    except:
        try:
            font = ImageFont.truetype(r"C:\Windows\Fonts\TIMESBD.TTF", font_size)
            font_bold = font
        except:
            font = ImageFont.load_default()
            font_bold = font
    
    # Wrap text th√¥ng minh
    words = dialogue_text.split()
    lines = []
    current_line = ""
    max_line_width = bubble_width - padding * 2
    
    for word in words:
        test_line = current_line + word + " "
        bbox = draw.textbbox((0, 0), test_line, font=font)
        line_width = bbox[2] - bbox[0]
        
        if line_width <= max_line_width:
            current_line = test_line
        else:
            if current_line:
                lines.append(current_line.strip())
            current_line = word + " "
    
    if current_line:
        lines.append(current_line.strip())
    
    # Gi·ªõi h·∫°n 3 d√≤ng
    lines = lines[:3]
    
    # T√≠nh to√°n k√≠ch th∆∞·ªõc bubble
    line_height = font_size + 8
    bubble_height = len(lines) * line_height + padding * 2
    
    # V·ªã tr√≠ bubble
    if position == "top":
        bubble_y = padding
    else:  # bottom
        bubble_y = h - bubble_height - padding
    
    bubble_x = padding
    
    # V·∫Ω SHADOW cho bubble
    shadow_offset = 4
    draw.rounded_rectangle(
        [bubble_x + shadow_offset, bubble_y + shadow_offset, 
         bubble_x + bubble_width + shadow_offset, bubble_y + bubble_height + shadow_offset],
        radius=15,
        fill=(0, 0, 0, 100)  # B√≥ng ƒëen m·ªù
    )
    
    # V·∫Ω BUBBLE ch√≠nh (tr·∫Øng v·ªõi opacity)
    draw.rounded_rectangle(
        [bubble_x, bubble_y, bubble_x + bubble_width, bubble_y + bubble_height],
        radius=15,
        fill=(255, 255, 255, 240),  # Tr·∫Øng g·∫ßn nh∆∞ ƒë·ª•c
        outline=(0, 0, 0, 255),  # Vi·ªÅn ƒëen
        width=3
    )
    
    # V·∫Ω TEXT
    text_y = bubble_y + padding
    for line in lines:
        # T√≠nh to√°n ƒë·ªÉ CENTER text
        bbox = draw.textbbox((0, 0), line, font=font)
        text_width = bbox[2] - bbox[0]
        text_x = bubble_x + (bubble_width - text_width) // 2
        
        # V·∫Ω TEXT SHADOW
        draw.text(
            (text_x + 2, text_y + 2),
            line,
            fill=(150, 150, 150, 180),
            font=font
        )
        
        # V·∫Ω TEXT ch√≠nh
        draw.text(
            (text_x, text_y),
            line,
            fill=(0, 0, 0, 255),
            font=font
        )
        
        text_y += line_height
    
    return img


# üéØ T·∫°o t·∫•t c·∫£ ·∫£nh panels v·ªõi DETAILED PROMPTS
# if story_script:
#     print("\n" + "=" * 70)
#     print("üéØ B·∫ÆT ƒê·∫¶U T·∫†O ·∫¢NH CHO T·ª™NG PANEL")
#     print("=" * 70)
#     print("üìå S·ª≠ d·ª•ng DETAILED PROMPTS ƒë√£ sinh")
#     print("üìå M·ªói ·∫£nh: K√çCH TH∆Ø·ªöC CH√çNH X√ÅC theo Gemini aspect ratios")
#     print("üìå Nh√¢n v·∫≠t nh·∫•t qu√°n qua detailed character descriptions")
#     print("üìå L·ªùi tho·∫°i: Font ƒê·∫∏P, bubble tr√≤n, shadow")
#     print("=" * 70)
    
#     # ‚≠ê S·ª¨ D·ª§NG H√ÄM M·ªöI create_panel_images_v2
#     panel_images = create_panel_images_v2(story_script, selected_layouts)
    
#     total_panels = sum([len(p) for p in panel_images.values()])
#     print(f"\n‚úÖ ƒê√É T·∫†O XONG {total_panels} PANELS!")
#     print(f"   üìñ T·∫•t c·∫£ trang: Nh√¢n v·∫≠t nh·∫•t qu√°n nh·ªù detailed prompts")
# else:
#     print("‚ùå Thi·∫øu d·ªØ li·ªáu. Vui l√≤ng ch·∫°y l·∫°i c√°c b∆∞·ªõc tr∆∞·ªõc.")



# üéØ T·∫°o t·∫•t c·∫£ ·∫£nh panels v·ªõi DETAILED PROMPTS
if story_script:
    print("\n" + "=" * 70)
    print("üéØ B·∫ÆT ƒê·∫¶U T·∫†O ·∫¢NH CHO T·ª™NG PANEL")
    print("=" * 70)
    print("üìå S·ª≠ d·ª•ng detailed prompts ƒë√£ sinh")
    print("üìå M·ªói ·∫£nh: K√çCH TH∆Ø·ªöC CH√çNH X√ÅC theo Gemini aspect ratios")
    print("üìå Nh√¢n v·∫≠t nh·∫•t qu√°n qua detailed character descriptions")
    print("üìå L·ªùi tho·∫°i: Font ƒê·∫∏P, bubble tr√≤n, shadow")
    print("=" * 70)
    
    panel_images = create_panel_images_v2(story_script, selected_layouts)
    
    total_panels = sum([len(p) for p in panel_images.values()])
    print(f"\n‚úÖ ƒê√É T·∫†O XONG {total_panels} PANELS!")
    print(f"   üìñ T·∫•t c·∫£ trang: Nh√¢n v·∫≠t nh·∫•t qu√°n nh·ªù detailed prompts")
else:
    print("‚ùå Thi·∫øu d·ªØ li·ªáu. Vui l√≤ng ch·∫°y l·∫°i c√°c b∆∞·ªõc tr∆∞·ªõc.")


# üìÑ Gh√©p c√°c panel th√†nh trang ho√†n ch·ªânh
def compose_page(page_num, panels):
    """
    Gh√©p c√°c panel th√†nh m·ªôt trang A4 ho√†n ch·ªânh
    """
    # T·∫°o canvas tr·∫Øng A4
    page_img = Image.new("RGB", (PAGE_W, PAGE_H), "white")
    
    # D√°n t·ª´ng panel v√†o v·ªã tr√≠ c·ªßa n√≥
    for panel in panels:
        x, y, w, h = panel['position']
        page_img.paste(panel['image'], (x, y))
    
    # V·∫Ω vi·ªÅn cho c√°c panel
    draw = ImageDraw.Draw(page_img)
    for panel in panels:
        x, y, w, h = panel['position']
        draw.rectangle([x, y, x+w, y+h], outline="black", width=5)
    
    return page_img

# Gh√©p t·∫•t c·∫£ c√°c trang (B·ªé QUA TRANG 0 - DEMO)
final_pages = []
demo_page_path = None
os.makedirs("final_comic", exist_ok=True)

if 'panel_images' in locals():
    print("\nüìÑ ƒêang gh√©p c√°c panel th√†nh trang...")
    
    for page_num in sorted(panel_images.keys()):
        panels = panel_images[page_num]
        
        print(f"   Trang {page_num}: Gh√©p {len(panels)} panels...")
        
        page_img = compose_page(page_num, panels)
        
        # L∆∞u trang
        if page_num == 0:
            # TRANG 0: L∆∞u ri√™ng v√†o demo
            page_path = f"final_comic/page_00_DEMO_CHARACTER_REFERENCE.png"
            demo_page_path = page_path
            print(f"   üìå DEMO PAGE - Kh√¥ng t√≠nh v√†o truy·ªán ch√≠nh")
        else:
            # TRANG 1+: Trang truy·ªán th·∫≠t
            page_path = f"final_comic/page_{page_num:02d}.png"
            final_pages.append(page_path)
        
        page_img.save(page_path, quality=95)
        print(f"   ‚úÖ ƒê√£ l∆∞u: {page_path}")
    
    print(f"\n‚úÖ Ho√†n th√†nh gh√©p {len(panel_images)} trang!")
    print(f"   üìå Trang DEMO: {demo_page_path if demo_page_path else 'Kh√¥ng c√≥'}")
    print(f"   üìñ Trang truy·ªán: {len(final_pages)} trang")
else:
    print("‚ùå Ch∆∞a c√≥ d·ªØ li·ªáu panel. Vui l√≤ng ch·∫°y l·∫°i b∆∞·ªõc 5.")





# üì¶ T·∫°o b√°o c√°o v√† th√¥ng tin truy·ªán
if story_script and 'final_pages' in locals():
    # T·∫°o file info
    comic_info = {
        "title": story_script['title'],
        "art_style": story_script['art_style'],
        "num_pages": len(final_pages),
        "characters": story_script['characters'],
        "created_at": time.strftime("%Y-%m-%d %H:%M:%S"),
        "pages": []
    }
    
    for i, page_path in enumerate(final_pages):
        page_num = i + 1
        comic_info['pages'].append({
            "page_num": page_num,
            "file": page_path,
            "layout": selected_layouts[i]['layout_name'],
            "num_panels": len(panel_images[page_num])
        })
    
    # L∆∞u th√¥ng tin truy·ªán
    with open("final_comic/comic_info.json", "w", encoding="utf-8") as f:
        json.dump(comic_info, f, indent=2, ensure_ascii=False)
    
    # T·∫°o README - X·ª≠ l√Ω character appearance
    character_descriptions = []
    for c in story_script['characters']:
        if 'appearance' in c:
            app = c['appearance']
            desc = f"{app.get('age', 'unknown age')}, {app.get('hair', 'unknown hair')}, {app.get('eyes', 'unknown eyes')}"
        elif 'description' in c:
            # Fallback cho format c≈©
            desc = c['description']
        else:
            desc = "No description available"
        character_descriptions.append(f'- **{c["name"]}** ({c.get("role", "unknown")}): {desc}')
    
    readme_content = f"""
# {story_script['title']}

## Th√¥ng tin truy·ªán
- **Phong c√°ch**: {story_script['art_style']}
- **Th·ªÉ lo·∫°i**: {story_script.get('genre', 'N/A')}
- **S·ªë trang**: {len(final_pages)}
- **S·ªë nh√¢n v·∫≠t**: {len(story_script['characters'])}
- **Ng√†y t·∫°o**: {time.strftime("%Y-%m-%d %H:%M:%S")}

## Nh√¢n v·∫≠t
{chr(10).join(character_descriptions)}

## C·∫•u tr√∫c
{chr(10).join([f'- Trang {p["page_num"]}: {p["layout"]} ({p["num_panels"]} panels)' for p in comic_info['pages']])}

## Files
- `comic_info.json`: Th√¥ng tin chi ti·∫øt truy·ªán
- `page_01.png` - `page_{len(final_pages):02d}.png`: C√°c trang truy·ªán

---
T·∫°o b·ªüi Comic Auto Creator v·ªõi Gemini AI
"""
    
    with open("final_comic/README.md", "w", encoding="utf-8") as f:
        f.write(readme_content)
    
    print("\n" + "="*60)
    print("üéâ HO√ÄN TH√ÄNH T·∫†O TRUY·ªÜN!")
    print("="*60)
    print(f"\nüìö T√™n truy·ªán: {story_script['title']}")
    print(f"üìÑ S·ªë trang: {len(final_pages)}")
    print(f"üé® Phong c√°ch: {story_script['art_style']}")
    print(f"\nüìÅ Truy·ªán ƒë√£ ƒë∆∞·ª£c l∆∞u trong folder: final_comic/")
    print(f"\nC√°c file:")
    print(f"  - comic_info.json (th√¥ng tin truy·ªán)")
    print(f"  - README.md (h∆∞·ªõng d·∫´n)")
    for page_path in final_pages:
        print(f"  - {os.path.basename(page_path)}")
    print("\n" + "="*60)
else:
    print("‚ùå Ch∆∞a ƒë·ªß d·ªØ li·ªáu ƒë·ªÉ ho√†n th√†nh. Vui l√≤ng ch·∫°y l·∫°i c√°c b∆∞·ªõc tr∆∞·ªõc.")



# üìÑ G·ªôp t·∫•t c·∫£ trang th√†nh 1 file PDF
def create_comic_pdf(final_pages, output_filename="final_comic/TRUYEN_TRANH.pdf"):
    """
    G·ªôp t·∫•t c·∫£ trang PNG th√†nh 1 file PDF duy nh·∫•t
    """
    try:
        from PIL import Image
        
        if not final_pages:
            print("‚ùå Kh√¥ng c√≥ trang n√†o ƒë·ªÉ t·∫°o PDF")
            return None
        
        print(f"\nüìÑ ƒêang t·∫°o PDF t·ª´ {len(final_pages)} trang...")
        
        # ƒê·ªçc t·∫•t c·∫£ trang
        images = []
        for i, page_path in enumerate(final_pages):
            print(f"   ƒê·ªçc trang {i+1}/{len(final_pages)}: {page_path}")
            img = Image.open(page_path)
            
            # Convert sang RGB n·∫øu c·∫ßn (PDF kh√¥ng h·ªó tr·ª£ RGBA)
            if img.mode != 'RGB':
                img = img.convert('RGB')
            
            images.append(img)
        
        # L∆∞u th√†nh PDF (trang ƒë·∫ßu ti√™n l√†m g·ªëc, c√°c trang c√≤n l·∫°i append v√†o)
        if len(images) > 0:
            print(f"\nüíæ ƒêang l∆∞u PDF: {output_filename}")
            images[0].save(
                output_filename,
                save_all=True,
                append_images=images[1:] if len(images) > 1 else [],
                resolution=300.0,  # 300 DPI
                quality=95,
                optimize=False
            )
            
            # Ki·ªÉm tra file size
            import os
            file_size = os.path.getsize(output_filename) / (1024 * 1024)  # MB
            
            print(f"\n‚úÖ ƒê√É T·∫†O PDF TH√ÄNH C√îNG!")
            print(f"   üìÅ File: {output_filename}")
            print(f"   üìä K√≠ch th∆∞·ªõc: {file_size:.2f} MB")
            print(f"   üìÑ S·ªë trang: {len(images)}")
            
            return output_filename
        else:
            print("‚ùå Kh√¥ng c√≥ ·∫£nh n√†o ƒë·ªÉ t·∫°o PDF")
            return None
            
    except Exception as e:
        print(f"\n‚ùå L·ªói t·∫°o PDF: {e}")
        print("üí° Th·ª≠ c√†i ƒë·∫∑t: pip install Pillow")
        return None


# T·∫°o PDF n·∫øu ƒë√£ c√≥ final_pages
if 'final_pages' in locals() and final_pages:
    print("\n" + "=" * 70)
    print("üìÑ B∆Ø·ªöC CU·ªêI: T·∫†O FILE PDF")
    print("=" * 70)
    
    pdf_file = create_comic_pdf(final_pages)
    
    if pdf_file:
        print("\n" + "=" * 70)
        print("üéâ HO√ÄN TH√ÄNH TO√ÄN B·ªò QUY TR√åNH!")
        print("=" * 70)
        print(f"\nüìö Truy·ªán c·ªßa b·∫°n:")
        print(f"   - C√°c trang PNG: final_comic/page_*.png")
        print(f"   - File PDF ho√†n ch·ªânh: {pdf_file}")
        print(f"\nüìñ B·∫°n c√≥ th·ªÉ ƒë·ªçc truy·ªán b·∫±ng:")
        print(f"   - M·ªü file PDF b·∫±ng tr√¨nh ƒë·ªçc PDF")
        print(f"   - Ho·∫∑c xem t·ª´ng trang PNG")
        print("=" * 70)
else:
    print("‚ùå Ch∆∞a c√≥ d·ªØ li·ªáu trang. Vui l√≤ng ch·∫°y l·∫°i c√°c b∆∞·ªõc tr∆∞·ªõc.")



# üëÅÔ∏è Hi·ªÉn th·ªã preview c√°c trang (n·∫øu ch·∫°y trong notebook)
if 'final_pages' in locals():
    from IPython.display import display, Image as IPImage
    
    print("üìñ Preview truy·ªán:")
    for i, page_path in enumerate(final_pages[:3]):  # Hi·ªÉn th·ªã 3 trang ƒë·∫ßu
        print(f"\n--- Trang {i+1} ---")
        display(IPImage(filename=page_path, width=600))
    
    if len(final_pages) > 3:
        print(f"\n... v√† {len(final_pages) - 3} trang n·ªØa trong folder final_comic/")
else:
    print("‚ùå Ch∆∞a c√≥ trang n√†o ƒë·ªÉ hi·ªÉn th·ªã.")


