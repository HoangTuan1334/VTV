=== Sinh video v·ªõi Veo 3 (Quy tr√¨nh b·∫•t ƒë·ªìng b·ªô) | AI Th·ª±c Chi·∫øn ===
URL: https://docs.thucchien.ai/docs/user-guide/video-generation-veo3
Crawled: 2025-10-23 00:17:34
============================================================

MAIN CONTENT:
----------------------------------------
H∆∞·ªõng d·∫´n s·ª≠ d·ª•ng APISinh video v·ªõi Veo 3 (Quy tr√¨nh b·∫•t ƒë·ªìng b·ªô)
Sinh video v·ªõi Veo 3 (Quy tr√¨nh b·∫•t ƒë·ªìng b·ªô)
Vi·ªác t·∫°o video l√† m·ªôt t√°c v·ª• t·ªën nhi·ªÅu t√†i nguy√™n v√† th·ªùi gian. Do ƒë√≥, t∆∞∆°ng t√°c v·ªõi m√¥ h√¨nh veo 3 kh√¥ng di·ªÖn ra ngay l·∫≠p t·ª©c m√† theo m·ªôt quy tr√¨nh b·∫•t ƒë·ªìng b·ªô (asynchronous) g·ªìm 3 b∆∞·ªõc.
Model ƒë∆∞·ª£c h·ªó tr·ª£: veo 3 (Google Vertex AI)
T·ªïng quan quy tr√¨nh
B·∫Øt ƒë·∫ßu t√°c v·ª•: B·∫°n g·ª≠i m·ªôt y√™u c·∫ßu ch·ª©a m√¥ t·∫£ (prompt) ƒë·ªÉ b·∫Øt ƒë·∫ßu qu√° tr√¨nh t·∫°o video. API s·∫Ω tr·∫£ v·ªÅ m·ªôt operation_name ƒë·ªÉ b·∫°n theo d√µi.
Ki·ªÉm tra tr·∫°ng th√°i: B·∫°n s·ª≠ d·ª•ng operation_name ƒë·ªÉ h·ªèi API xem video ƒë√£ ƒë∆∞·ª£c t·∫°o xong ch∆∞a. B·∫°n c·∫ßn l·∫∑p l·∫°i b∆∞·ªõc n√†y cho ƒë·∫øn khi nh·∫≠n ƒë∆∞·ª£c tr·∫°ng th√°i ho√†n t·∫•t.
T·∫£i video: Khi video ƒë√£ s·∫µn s√†ng, k·∫øt qu·∫£ ki·ªÉm tra tr·∫°ng th√°i s·∫Ω ch·ª©a m·ªôt URI (ƒë∆∞·ªùng d·∫´n) ƒë·∫øn file video. B·∫°n s·ª≠ d·ª•ng URI n√†y ƒë·ªÉ t·∫£i video v·ªÅ.
H∆∞·ªõng d·∫´n chi ti·∫øt
curl (T·ª´ng b∆∞·ªõc)
Python (Script t·ª± ƒë·ªông)
B∆∞·ªõc 1: B·∫Øt ƒë·∫ßu t·∫°o video
G·ª≠i m·ªôt y√™u c·∫ßu POST ƒë·∫øn endpoint ƒë·∫∑c bi·ªát d√†nh cho Veo.
QUAN TR·ªåNG
Do m√°y ch·ªß proxy ƒëang s·ª≠ d·ª•ng c∆° ch·∫ø pass-through t·ªõi Google AI Studio, b·∫°n s·∫Ω s·ª≠ d·ª•ng header x-goog-api-key thay cho header Authorization ti√™u chu·∫©n.
curl -X POST https://api.thucchien.ai/gemini/v1beta/models/veo-3.0-generate-preview:predictLongRunning \
-H "Content-Type: application/json" \
-H "x-goog-api-key: <your_api_key>" \
-d '{
  "instances": [{
    "prompt": "A cinematic shot of a hummingbird flying in slow motion"
  }]
}'
N·∫øu th√†nh c√¥ng, API s·∫Ω tr·∫£ v·ªÅ m·ªôt JSON ch·ª©a name c·ªßa t√°c v·ª•. H√£y l∆∞u l·∫°i gi√° tr·ªã n√†y.
{
"name": "models/veo-3.0-generate-preview/operations/idrk08ltkg0a"
}
Trong ƒë√≥:
operation_name: l√† to√†n b·ªô chu·ªói models/veo-3.0-generate-preview/operations/idrk08ltkg0a.
operation_id: l√† ph·∫ßn ƒë·ªãnh danh duy nh·∫•t c·ªßa t√°c v·ª•, trong v√≠ d·ª• n√†y l√† idrk08ltkg0a. B·∫°n s·∫Ω s·ª≠ d·ª•ng ID n√†y ·ªü b∆∞·ªõc ti·∫øp theo.
B∆∞·ªõc 2: Ki·ªÉm tra tr·∫°ng th√°i
S·ª≠ d·ª•ng operation_id (v√≠ d·ª•: idrk08ltkg0a) b·∫°n nh·∫≠n ƒë∆∞·ª£c ·ªü B∆∞·ªõc 1 ƒë·ªÉ x√¢y d·ª±ng URL v√† g·ª≠i y√™u c·∫ßu GET ƒë·ªÉ ki·ªÉm tra tr·∫°ng th√°i.
# URL ki·ªÉm tra tr·∫°ng th√°i: https://api.thucchien.ai/gemini/v1beta/models/veo-3.0-generate-preview/operations/idrk08ltkg0a
curl https://api.thucchien.ai/gemini/v1beta/models/veo-3.0-generate-preview/operations/<operation_id> \
-H "x-goog-api-key: <your_api_key>"
L·∫∑p l·∫°i y√™u c·∫ßu n√†y cho ƒë·∫øn khi response ch·ª©a "done": true.
{
  "name": "models/veo-3.0-generate-preview/operations/idrk08ltkg0a",
  "done": true,
  "response": {
      "@type": "type.googleapis.com/google.ai.generativelanguage.v1beta.PredictLongRunningResponse",
      "generateVideoResponse": {
          "generatedSamples": [
              {
                  "video": {
                      "uri": "https://generativelanguage.googleapis.com/v1beta/files/3j6svp4106e7:download?alt=media"
                  }
              }
          ]
      }
  }
}
Khi t√°c v·ª• ho√†n t·∫•t ("done": true), response s·∫Ω ch·ª©a m·ªôt tr∆∞·ªùng uri. T·ª´ URI n√†y, ch√∫ng ta c√≥ th·ªÉ tr√≠ch xu·∫•t ra video_id, trong tr∆∞·ªùng h·ª£p n√†y l√† 3j6svp4106e7. ID n√†y ƒë∆∞·ª£c d√πng ƒë·ªÉ t·∫£i video ·ªü b∆∞·ªõc cu·ªëi c√πng.
B∆∞·ªõc 3: T·∫£i video
S·ª≠ d·ª•ng video_id (v√≠ d·ª•: 3j6svp4106e7) ƒë√£ tr√≠ch xu·∫•t ·ªü B∆∞·ªõc 2 ƒë·ªÉ t·∫°o URL t·∫£i xu·ªëng cu·ªëi c√πng th√¥ng qua proxy.
# URI g·ªëc t·ª´ Google: https://generativelanguage.googleapis.com/v1beta/files/3j6svp4106e7:download?alt=media
# ƒê∆∞·ªùng d·∫´n t∆∞∆°ng ƒë·ªëi c·∫ßn d√πng: v1beta/files/3j6svp4106e7:download?alt=media
# URL t·∫£i xu·ªëng qua proxy: https://api.thucchien.ai/gemini/download/v1beta/files/3j6svp4106e7:download?alt=media

curl https://api.thucchien.ai/gemini/download/v1beta/files/<video_id>:download?alt=media \
-H "x-goog-api-key: <your_api_key>" \
--output my_generated_video.mp4
K·∫øt qu·∫£ b·∫°n s·∫Ω c√≥ file video nh∆∞ sau:
Your browser does not support the video tag.


























































































































































































































































































































C√°c tham s·ªë t√πy ch·ªçn
Ngo√†i prompt, b·∫°n c√≥ th·ªÉ ch·ªâ ƒë·ªãnh th√™m c√°c tham s·ªë kh√°c trong body c·ªßa y√™u c·∫ßu ·ªü B∆∞·ªõc 1 ƒë·ªÉ ki·ªÉm so√°t video ƒë∆∞·ª£c t·∫°o ra, v√≠ d·ª• nh∆∞ th·ªùi l∆∞·ª£ng, ch·∫•t l∆∞·ª£ng, v.v.
ƒê·ªÉ bi·∫øt danh s√°ch ƒë·∫ßy ƒë·ªß c√°c tham s·ªë v√† c√°ch s·ª≠ d·ª•ng, vui l√≤ng tham kh·∫£o t√†i li·ªáu ch√≠nh th·ª©c t·∫°i ƒë√¢y: Google AI for Developers - Video Generation.
Previous
Sinh h√¨nh ·∫£nh (Image Generation)
Next
Chuy·ªÉn vƒÉn b·∫£n th√†nh gi·ªçng n√≥i (Text-to-Speech)
T·ªïng quan quy tr√¨nh
H∆∞·ªõng d·∫´n chi ti·∫øt
C√°c tham s·ªë t√πy ch·ªçn

TAB CONTENT:
----------------------------------------

[TAB: curl (T·ª´ng b∆∞·ªõc)_0]
curl -X POST https://api.thucchien.ai/gemini/v1beta/models/veo-3.0-generate-preview:predictLongRunning \
-H "Content-Type: application/json" \
-H "x-goog-api-key: <your_api_key>" \
-d '{
  "instances": [{
    "prompt": "A cinematic shot of a hummingbird flying in slow motion"
  }]
}'
..............................

[TAB: Python (Script t·ª± ƒë·ªông)_1]
#!/usr/bin/env python3
"""
Complete example for Veo video generation through LiteLLM proxy.

This script demonstrates how to:
1. Generate videos using Google's Veo model
2. Poll for completion status
3. Download the generated video file

Requirements:
- LiteLLM proxy running with Google AI Studio pass-through configured
- Google AI Studio API key with Veo access

# This file is forked and adapted from: https://github.com/BerriAI/litellm/blob/main/docs/my-website/docs/proxy/veo_video_generation.md .Please refer to the original for license details.
"""

import json
import os
import time
import requests
from typing import Optional


class VeoVideoGenerator:
  """Complete Veo video generation client using LiteLLM proxy."""
  
  def __init__(self, base_url: str = "https://api.thucchien.ai/gemini/v1beta", 
               api_key: str = "sk-1234"):
      """
      Initialize the Veo video generator.
      
      Args:
          base_url: Base URL for the LiteLLM proxy with Gemini pass-through
          api_key: API key for LiteLLM proxy authentication
      """
      self.base_url = base_url
      self.api_key = api_key
      self.headers = {
          "x-goog-api-key": api_key,
          "Content-Type": "application/json"
      }
  
  def generate_video(self, prompt: str) -> Optional[str]:
      """
      Initiate video generation with Veo.
      
      Args:
          prompt: Text description of the video to generate
          
      Returns:
          Operation name if successful, None otherwise
      """
      print(f"üé¨ Generating video with prompt: '{prompt}'")
      
      url = f"{self.base_url}/models/veo-3.0-generate-preview:predictLongRunning"
      payload = {
          "instances": [{
              "prompt": prompt
          }]
      }
      
      try:
          response = requests.post(url, headers=self.headers, json=payload)
          response.raise_for_status()
          
          data = response.json()
          operation_name = data.get("name")
          
          if operation_name:
              print(f"‚úÖ Video generation started: {operation_name}")
              return operation_name
          else:
              print("‚ùå No operation name returned")
              print(f"Response: {json.dumps(data, indent=2)}")
              return None
              
      except requests.RequestException as e:
          print(f"‚ùå Failed to start video generation: {e}")
          if hasattr(e, 'response') and e.response is not None:
              try:
                  error_data = e.response.json()
                  print(f"Error details: {json.dumps(error_data, indent=2)}")
              except:
                  print(f"Error response: {e.response.text}")
          return None
  
  def wait_for_completion(self, operation_name: str, max_wait_time: int = 600) -> Optional[str]:
      """
      Poll operation status until video generation is complete.
      
      Args:
          operation_name: Name of the operation to monitor
          max_wait_time: Maximum time to wait in seconds (default: 10 minutes)
          
      Returns:
          Video URI if successful, None otherwise
      """
      print("‚è≥ Waiting for video generation to complete...")
      
      operation_url = f"{self.base_url}/{operation_name}"
      start_time = time.time()
      poll_interval = 10  # Start with 10 seconds
      
      while time.time() - start_time < max_wait_time:
          try:
              print(f"üîç Polling status... ({int(time.time() - start_time)}s elapsed)")
              
              response = requests.get(operation_url, headers=self.headers)
              response.raise_for_status()
              
              data = response.json()
              
              # Check for errors
              if "error" in data:
                  print("‚ùå Error in video generation:")
                  print(json.dumps(data["error"], indent=2))
                  return None
              
              # Check if operation is complete
              is_done = data.get("done", False)
              
              if is_done:
                  print("üéâ Video generation complete!")
                  
                  try:
                      # Extract video URI from nested response
                      video_uri = data["response"]["generateVideoResponse"]["generatedSamples"][0]["video"]["uri"]
                      print(f"üìπ Video URI: {video_uri}")
                      return video_uri
                  except KeyError as e:
                      print(f"‚ùå Could not extract video URI: {e}")
                      print("Full response:")
                      print(json.dumps(data, indent=2))
                      return None
              
              # Wait before next poll, with exponential backoff
              time.sleep(poll_interval)
              poll_interval = min(poll_interval * 1.2, 30)  # Cap at 30 seconds
              
          except requests.RequestException as e:
              print(f"‚ùå Error polling operation status: {e}")
              time.sleep(poll_interval)
      
      print(f"‚è∞ Timeout after {max_wait_time} seconds")
      return None
  
  def download_video(self, video_uri: str, output_filename: str = "generated_video.mp4") -> bool:
      """
      Download the generated video file.
      
      Args:
          video_uri: URI of the video to download (from Google's response)
          output_filename: Local filename to save the video
          
      Returns:
          True if download successful, False otherwise
      """
      print(f"‚¨áÔ∏è  Downloading video...")
      print(f"Original URI: {video_uri}")
      
      # Convert Google URI to LiteLLM proxy URI
      # Example: https://generativelanguage.googleapis.com/v1beta/files/abc123 -> /gemini/download/v1beta/files/abc123:download?alt=media
      if video_uri.startswith("https://generativelanguage.googleapis.com/"):
          relative_path = video_uri.replace(
              "https://generativelanguage.googleapis.com/",
              ""
          )
      else:
          relative_path = video_uri

      # base_url: https://api.thucchien.ai/gemini/v1beta
      if self.base_url.endswith("/v1beta"):
          base_path = self.base_url.replace("/v1beta", "/download")
      else:
          base_path = self.base_url

      litellm_download_url = f"{base_path}/{relative_path}"
      print(f"Download URL: {litellm_download_url}")
      
      try:
          # Download with streaming and redirect handling
          response = requests.get(
              litellm_download_url, 
              headers=self.headers, 
              stream=True,
              allow_redirects=True  # Handle redirects automatically
          )
          response.raise_for_status()
          
          # Save video file
          with open(output_filename, 'wb') as f:
              downloaded_size = 0
              for chunk in response.iter_content(chunk_size=8192):
                  if chunk:
                      f.write(chunk)
                      downloaded_size += len(chunk)
                      
                      # Progress indicator for large files
                      if downloaded_size % (1024 * 1024) == 0:  # Every MB
                          print(f"üì¶ Downloaded {downloaded_size / (1024*1024):.1f} MB...")
          
          # Verify file was created and has content
          if os.path.exists(output_filename):
              file_size = os.path.getsize(output_filename)
              if file_size > 0:
                  print(f"‚úÖ Video downloaded successfully!")
                  print(f"üìÅ Saved as: {output_filename}")
                  print(f"üìè File size: {file_size / (1024*1024):.2f} MB")
                  return True
              else:
                  print("‚ùå Downloaded file is empty")
                  os.remove(output_filename)
                  return False
          else:
              print("‚ùå File was not created")
              return False
              
      except requests.RequestException as e:
          print(f"‚ùå Download failed: {e}")
          if hasattr(e, 'response') and e.response is not None:
              print(f"Status code: {e.response.status_code}")
              print(f"Response headers: {dict(e.response.headers)}")
          return False
  
  def generate_and_download(self, prompt: str, output_filename: str = None) -> bool:
      """
      Complete workflow: generate video and download it.
      
      Args:
          prompt: Text description for video generation
          output_filename: Output filename (auto-generated if None)
          
      Returns:
          True if successful, False otherwise
      """
      # Auto-generate filename if not provided
      if output_filename is None:
          timestamp = int(time.time())
          safe_prompt = "".join(c for c in prompt[:30] if c.isalnum() or c in (' ', '-', '_')).rstrip()
          output_filename = f"veo_video_{safe_prompt.replace(' ', '_')}_{timestamp}.mp4"
      
      print("=" * 60)
      print("üé¨ VEO VIDEO GENERATION WORKFLOW")
      print("=" * 60)
      
      # Step 1: Generate video
      operation_name = self.generate_video(prompt)
      if not operation_name:
          return False
      
      # Step 2: Wait for completion
      video_uri = self.wait_for_completion(operation_name)
      if not video_uri:
          return False
      
      # Step 3: Download video
      success = self.download_video(video_uri, output_filename)
      
      if success:
          print("=" * 60)
          print("üéâ SUCCESS! Video generation complete!")
          print(f"üìÅ Video saved as: {output_filename}")
          print("=" * 60)
      else:
          print("=" * 60)
          print("‚ùå FAILED! Video generation or download failed")
          print("=" * 60)
      
      return success


def main():
  """
  Example usage of the VeoVideoGenerator.
  
  Configure these environment variables:
  - LITELLM_BASE_URL: Your LiteLLM proxy URL (default: https://api.thucchien.ai/gemini/v1beta)
  - LITELLM_API_KEY: Your LiteLLM API key (default: sk-1234)
  """
  
  # Configuration from environment or defaults
  base_url = os.getenv("LITELLM_BASE_URL", "https://api.thucchien.ai/gemini/v1beta")
  api_key = os.getenv("LITELLM_API_KEY", "sk-1234")
  
  print("üöÄ Starting Veo Video Generation Example")
  print(f"üì° Using LiteLLM proxy at: {base_url}")
  
  # Initialize generator
  generator = VeoVideoGenerator(base_url=base_url, api_key=api_key)
  
  # Example prompts - try different ones!
  example_prompts = [
      "A cat playing with a ball of yarn in a sunny garden",
      "Ocean waves crashing against rocky cliffs at sunset",
      "A bustling city street with people walking and cars passing by",
      "A peaceful forest with sunlight filtering through the trees"
  ]
  
  # Use first example or get from user
  prompt = example_prompts[0]
  print(f"üé¨ Using prompt: '{prompt}'")
  
  # Generate and download video
  success = generator.generate_and_download(prompt)
  
  if success:
      print("‚úÖ Example completed successfully!")
      print("üí° Try modifying the prompt in the script for different videos!")
  else:
      print("‚ùå Example failed!")
      print("üîß Check your API Configuration")

if __name__ == "__main__":
  main()
..............................

CODE BLOCKS:
----------------------------------------

[CODE: unknown_code_6]
```
#!/usr/bin/env python3
"""
Complete example for Veo video generation through LiteLLM proxy.

This script demonstrates how to:
1. Generate videos using Google's Veo model
2. Poll for completion status
3. Download the generated video file

Requirements:
- LiteLLM proxy running with Google AI Studio pass-through configured
- Google AI Studio API key with Veo access

# This file is forked and adapted from: https://github.com/BerriAI/litellm/blob/main/docs/my-website/docs/proxy/veo_video_generation.md .Please refer to the original for license details.
"""

import json
import os
import time
import requests
from typing import Optional


class VeoVideoGenerator:
  """Complete Veo video generation client using LiteLLM proxy."""
  
  def __init__(self, base_url: str = "https://api.thucchien.ai/gemini/v1beta", 
               api_key: str = "sk-1234"):
      """
      Initialize the Veo video generator.
      
      Args:
          base_url: Base URL for the LiteLLM proxy with Gemini pass-through
          api_key: API key for LiteLLM proxy authentication
      """
      self.base_url = base_url
      self.api_key = api_key
      self.headers = {
          "x-goog-api-key": api_key,
          "Content-Type": "application/json"
      }
  
  def generate_video(self, prompt: str) -> Optional[str]:
      """
      Initiate video generation with Veo.
      
      Args:
          prompt: Text description of the video to generate
          
      Returns:
          Operation name if successful, None otherwise
      """
      print(f"üé¨ Generating video with prompt: '{prompt}'")
      
      url = f"{self.base_url}/models/veo-3.0-generate-preview:predictLongRunning"
      payload = {
          "instances": [{
              "prompt": prompt
          }]
      }
      
      try:
          response = requests.post(url, headers=self.headers, json=payload)
          response.raise_for_status()
          
          data = response.json()
          operation_name = data.get("name")
          
          if operation_name:
              print(f"‚úÖ Video generation started: {operation_name}")
              return operation_name
          else:
              print("‚ùå No operation name returned")
              print(f"Response: {json.dumps(data, indent=2)}")
              return None
              
      except requests.RequestException as e:
          print(f"‚ùå Failed to start video generation: {e}")
          if hasattr(e, 'response') and e.response is not None:
              try:
                  error_data = e.response.json()
                  print(f"Error details: {json.dumps(error_data, indent=2)}")
              except:
                  print(f"Error response: {e.response.text}")
          return None
  
  def wait_for_completion(self, operation_name: str, max_wait_time: int = 600) -> Optional[str]:
      """
      Poll operation status until video generation is complete.
      
      Args:
          operation_name: Name of the operation to monitor
          max_wait_time: Maximum time to wait in seconds (default: 10 minutes)
          
      Returns:
          Video URI if successful, None otherwise
      """
      print("‚è≥ Waiting for video generation to complete...")
      
      operation_url = f"{self.base_url}/{operation_name}"
      start_time = time.time()
      poll_interval = 10  # Start with 10 seconds
      
      while time.time() - start_time < max_wait_time:
          try:
              print(f"üîç Polling status... ({int(time.time() - start_time)}s elapsed)")
              
              response = requests.get(operation_url, headers=self.headers)
              response.raise_for_status()
              
              data = response.json()
              
              # Check for errors
              if "error" in data:
                  print("‚ùå Error in video generation:")
                  print(json.dumps(data["error"], indent=2))
                  return None
              
              # Check if operation is complete
              is_done = data.get("done", False)
              
              if is_done:
                  print("üéâ Video generation complete!")
                  
                  try:
                      # Extract video URI from nested response
                      video_uri = data["response"]["generateVideoResponse"]["generatedSamples"][0]["video"]["uri"]
                      print(f"üìπ Video URI: {video_uri}")
                      return video_uri
                  except KeyError as e:
                      print(f"‚ùå Could not extract video URI: {e}")
                      print("Full response:")
                      print(json.dumps(data, indent=2))
                      return None
              
              # Wait before next poll, with exponential backoff
              time.sleep(poll_interval)
              poll_interval = min(poll_interval * 1.2, 30)  # Cap at 30 seconds
              
          except requests.RequestException as e:
              print(f"‚ùå Error polling operation status: {e}")
              time.sleep(poll_interval)
      
      print(f"‚è∞ Timeout after {max_wait_time} seconds")
      return None
  
  def download_video(self, video_uri: str, output_filename: str = "generated_video.mp4") -> bool:
      """
      Download the generated video file.
      
      Args:
          video_uri: URI of the video to download (from Google's response)
          output_filename: Local filename to save the video
          
      Returns:
          True if download successful, False otherwise
      """
      print(f"‚¨áÔ∏è  Downloading video...")
      print(f"Original URI: {video_uri}")
      
      # Convert Google URI to LiteLLM proxy URI
      # Example: https://generativelanguage.googleapis.com/v1beta/files/abc123 -> /gemini/download/v1beta/files/abc123:download?alt=media
      if video_uri.startswith("https://generativelanguage.googleapis.com/"):
          relative_path = video_uri.replace(
              "https://generativelanguage.googleapis.com/",
              ""
          )
      else:
          relative_path = video_uri

      # base_url: https://api.thucchien.ai/gemini/v1beta
      if self.base_url.endswith("/v1beta"):
          base_path = self.base_url.replace("/v1beta", "/download")
      else:
          base_path = self.base_url

      litellm_download_url = f"{base_path}/{relative_path}"
      print(f"Download URL: {litellm_download_url}")
      
      try:
          # Download with streaming and redirect handling
          response = requests.get(
              litellm_download_url, 
              headers=self.headers, 
              stream=True,
              allow_redirects=True  # Handle redirects automatically
          )
          response.raise_for_status()
          
          # Save video file
          with open(output_filename, 'wb') as f:
              downloaded_size = 0
              for chunk in response.iter_content(chunk_size=8192):
                  if chunk:
                      f.write(chunk)
                      downloaded_size += len(chunk)
                      
                      # Progress indicator for large files
                      if downloaded_size % (1024 * 1024) == 0:  # Every MB
                          print(f"üì¶ Downloaded {downloaded_size / (1024*1024):.1f} MB...")
          
          # Verify file was created and has content
          if os.path.exists(output_filename):
              file_size = os.path.getsize(output_filename)
              if file_size > 0:
                  print(f"‚úÖ Video downloaded successfully!")
                  print(f"üìÅ Saved as: {output_filename}")
                  print(f"üìè File size: {file_size / (1024*1024):.2f} MB")
                  return True
              else:
                  print("‚ùå Downloaded file is empty")
                  os.remove(output_filename)
                  return False
          else:
              print("‚ùå File was not created")
              return False
              
      except requests.RequestException as e:
          print(f"‚ùå Download failed: {e}")
          if hasattr(e, 'response') and e.response is not None:
              print(f"Status code: {e.response.status_code}")
              print(f"Response headers: {dict(e.response.headers)}")
          return False
  
  def generate_and_download(self, prompt: str, output_filename: str = None) -> bool:
      """
      Complete workflow: generate video and download it.
      
      Args:
          prompt: Text description for video generation
          output_filename: Output filename (auto-generated if None)
          
      Returns:
          True if successful, False otherwise
      """
      # Auto-generate filename if not provided
      if output_filename is None:
          timestamp = int(time.time())
          safe_prompt = "".join(c for c in prompt[:30] if c.isalnum() or c in (' ', '-', '_')).rstrip()
          output_filename = f"veo_video_{safe_prompt.replace(' ', '_')}_{timestamp}.mp4"
      
      print("=" * 60)
      print("üé¨ VEO VIDEO GENERATION WORKFLOW")
      print("=" * 60)
      
      # Step 1: Generate video
      operation_name = self.generate_video(prompt)
      if not operation_name:
          return False
      
      # Step 2: Wait for completion
      video_uri = self.wait_for_completion(operation_name)
      if not video_uri:
          return False
      
      # Step 3: Download video
      success = self.download_video(video_uri, output_filename)
      
      if success:
          print("=" * 60)
          print("üéâ SUCCESS! Video generation complete!")
          print(f"üìÅ Video saved as: {output_filename}")
          print("=" * 60)
      else:
          print("=" * 60)
          print("‚ùå FAILED! Video generation or download failed")
          print("=" * 60)
      
      return success


def main():
  """
  Example usage of the VeoVideoGenerator.
  
  Configure these environment variables:
  - LITELLM_BASE_URL: Your LiteLLM proxy URL (default: https://api.thucchien.ai/gemini/v1beta)
  - LITELLM_API_KEY: Your LiteLLM API key (default: sk-1234)
  """
  
  # Configuration from environment or defaults
  base_url = os.getenv("LITELLM_BASE_URL", "https://api.thucchien.ai/gemini/v1beta")
  api_key = os.getenv("LITELLM_API_KEY", "sk-1234")
  
  print("üöÄ Starting Veo Video Generation Example")
  print(f"üì° Using LiteLLM proxy at: {base_url}")
  
  # Initialize generator
  generator = VeoVideoGenerator(base_url=base_url, api_key=api_key)
  
  # Example prompts - try different ones!
  example_prompts = [
      "A cat playing with a ball of yarn in a sunny garden",
      "Ocean waves crashing against rocky cliffs at sunset",
      "A bustling city street with people walking and cars passing by",
      "A peaceful forest with sunlight filtering through the trees"
  ]
  
  # Use first example or get from user
  prompt = example_prompts[0]
  print(f"üé¨ Using prompt: '{prompt}'")
  
  # Generate and download video
  success = generator.generate_and_download(prompt)
  
  if success:
      print("‚úÖ Example completed successfully!")
      print("üí° Try modifying the prompt in the script for different videos!")
  else:
      print("‚ùå Example failed!")
      print("üîß Check your API Configuration")

if __name__ == "__main__":
  main()
```
..............................

[CODE: python_code_1]
```
#!/usr/bin/env python3
"""
Complete example for Veo video generation through LiteLLM proxy.

This script demonstrates how to:
1. Generate videos using Google's Veo model
2. Poll for completion status
3. Download the generated video file

Requirements:
- LiteLLM proxy running with Google AI Studio pass-through configured
- Google AI Studio API key with Veo access

# This file is forked and adapted from: https://github.com/BerriAI/litellm/blob/main/docs/my-website/docs/proxy/veo_video_generation.md .Please refer to the original for license details.
"""

import json
import os
import time
import requests
from typing import Optional


class VeoVideoGenerator:
  """Complete Veo video generation client using LiteLLM proxy."""
  
  def __init__(self, base_url: str = "https://api.thucchien.ai/gemini/v1beta", 
               api_key: str = "sk-1234"):
      """
      Initialize the Veo video generator.
      
      Args:
          base_url: Base URL for the LiteLLM proxy with Gemini pass-through
          api_key: API key for LiteLLM proxy authentication
      """
      self.base_url = base_url
      self.api_key = api_key
      self.headers = {
          "x-goog-api-key": api_key,
          "Content-Type": "application/json"
      }
  
  def generate_video(self, prompt: str) -> Optional[str]:
      """
      Initiate video generation with Veo.
      
      Args:
          prompt: Text description of the video to generate
          
      Returns:
          Operation name if successful, None otherwise
      """
      print(f"üé¨ Generating video with prompt: '{prompt}'")
      
      url = f"{self.base_url}/models/veo-3.0-generate-preview:predictLongRunning"
      payload = {
          "instances": [{
              "prompt": prompt
          }]
      }
      
      try:
          response = requests.post(url, headers=self.headers, json=payload)
          response.raise_for_status()
          
          data = response.json()
          operation_name = data.get("name")
          
          if operation_name:
              print(f"‚úÖ Video generation started: {operation_name}")
              return operation_name
          else:
              print("‚ùå No operation name returned")
              print(f"Response: {json.dumps(data, indent=2)}")
              return None
              
      except requests.RequestException as e:
          print(f"‚ùå Failed to start video generation: {e}")
          if hasattr(e, 'response') and e.response is not None:
              try:
                  error_data = e.response.json()
                  print(f"Error details: {json.dumps(error_data, indent=2)}")
              except:
                  print(f"Error response: {e.response.text}")
          return None
  
  def wait_for_completion(self, operation_name: str, max_wait_time: int = 600) -> Optional[str]:
      """
      Poll operation status until video generation is complete.
      
      Args:
          operation_name: Name of the operation to monitor
          max_wait_time: Maximum time to wait in seconds (default: 10 minutes)
          
      Returns:
          Video URI if successful, None otherwise
      """
      print("‚è≥ Waiting for video generation to complete...")
      
      operation_url = f"{self.base_url}/{operation_name}"
      start_time = time.time()
      poll_interval = 10  # Start with 10 seconds
      
      while time.time() - start_time < max_wait_time:
          try:
              print(f"üîç Polling status... ({int(time.time() - start_time)}s elapsed)")
              
              response = requests.get(operation_url, headers=self.headers)
              response.raise_for_status()
              
              data = response.json()
              
              # Check for errors
              if "error" in data:
                  print("‚ùå Error in video generation:")
                  print(json.dumps(data["error"], indent=2))
                  return None
              
              # Check if operation is complete
              is_done = data.get("done", False)
              
              if is_done:
                  print("üéâ Video generation complete!")
                  
                  try:
                      # Extract video URI from nested response
                      video_uri = data["response"]["generateVideoResponse"]["generatedSamples"][0]["video"]["uri"]
                      print(f"üìπ Video URI: {video_uri}")
                      return video_uri
                  except KeyError as e:
                      print(f"‚ùå Could not extract video URI: {e}")
                      print("Full response:")
                      print(json.dumps(data, indent=2))
                      return None
              
              # Wait before next poll, with exponential backoff
              time.sleep(poll_interval)
              poll_interval = min(poll_interval * 1.2, 30)  # Cap at 30 seconds
              
          except requests.RequestException as e:
              print(f"‚ùå Error polling operation status: {e}")
              time.sleep(poll_interval)
      
      print(f"‚è∞ Timeout after {max_wait_time} seconds")
      return None
  
  def download_video(self, video_uri: str, output_filename: str = "generated_video.mp4") -> bool:
      """
      Download the generated video file.
      
      Args:
          video_uri: URI of the video to download (from Google's response)
          output_filename: Local filename to save the video
          
      Returns:
          True if download successful, False otherwise
      """
      print(f"‚¨áÔ∏è  Downloading video...")
      print(f"Original URI: {video_uri}")
      
      # Convert Google URI to LiteLLM proxy URI
      # Example: https://generativelanguage.googleapis.com/v1beta/files/abc123 -> /gemini/download/v1beta/files/abc123:download?alt=media
      if video_uri.startswith("https://generativelanguage.googleapis.com/"):
          relative_path = video_uri.replace(
              "https://generativelanguage.googleapis.com/",
              ""
          )
      else:
          relative_path = video_uri

      # base_url: https://api.thucchien.ai/gemini/v1beta
      if self.base_url.endswith("/v1beta"):
          base_path = self.base_url.replace("/v1beta", "/download")
      else:
          base_path = self.base_url

      litellm_download_url = f"{base_path}/{relative_path}"
      print(f"Download URL: {litellm_download_url}")
      
      try:
          # Download with streaming and redirect handling
          response = requests.get(
              litellm_download_url, 
              headers=self.headers, 
              stream=True,
              allow_redirects=True  # Handle redirects automatically
          )
          response.raise_for_status()
          
          # Save video file
          with open(output_filename, 'wb') as f:
              downloaded_size = 0
              for chunk in response.iter_content(chunk_size=8192):
                  if chunk:
                      f.write(chunk)
                      downloaded_size += len(chunk)
                      
                      # Progress indicator for large files
                      if downloaded_size % (1024 * 1024) == 0:  # Every MB
                          print(f"üì¶ Downloaded {downloaded_size / (1024*1024):.1f} MB...")
          
          # Verify file was created and has content
          if os.path.exists(output_filename):
              file_size = os.path.getsize(output_filename)
              if file_size > 0:
                  print(f"‚úÖ Video downloaded successfully!")
                  print(f"üìÅ Saved as: {output_filename}")
                  print(f"üìè File size: {file_size / (1024*1024):.2f} MB")
                  return True
              else:
                  print("‚ùå Downloaded file is empty")
                  os.remove(output_filename)
                  return False
          else:
              print("‚ùå File was not created")
              return False
              
      except requests.RequestException as e:
          print(f"‚ùå Download failed: {e}")
          if hasattr(e, 'response') and e.response is not None:
              print(f"Status code: {e.response.status_code}")
              print(f"Response headers: {dict(e.response.headers)}")
          return False
  
  def generate_and_download(self, prompt: str, output_filename: str = None) -> bool:
      """
      Complete workflow: generate video and download it.
      
      Args:
          prompt: Text description for video generation
          output_filename: Output filename (auto-generated if None)
          
      Returns:
          True if successful, False otherwise
      """
      # Auto-generate filename if not provided
      if output_filename is None:
          timestamp = int(time.time())
          safe_prompt = "".join(c for c in prompt[:30] if c.isalnum() or c in (' ', '-', '_')).rstrip()
          output_filename = f"veo_video_{safe_prompt.replace(' ', '_')}_{timestamp}.mp4"
      
      print("=" * 60)
      print("üé¨ VEO VIDEO GENERATION WORKFLOW")
      print("=" * 60)
      
      # Step 1: Generate video
      operation_name = self.generate_video(prompt)
      if not operation_name:
          return False
      
      # Step 2: Wait for completion
      video_uri = self.wait_for_completion(operation_name)
      if not video_uri:
          return False
      
      # Step 3: Download video
      success = self.download_video(video_uri, output_filename)
      
      if success:
          print("=" * 60)
          print("üéâ SUCCESS! Video generation complete!")
          print(f"üìÅ Video saved as: {output_filename}")
          print("=" * 60)
      else:
          print("=" * 60)
          print("‚ùå FAILED! Video generation or download failed")
          print("=" * 60)
      
      return success


def main():
  """
  Example usage of the VeoVideoGenerator.
  
  Configure these environment variables:
  - LITELLM_BASE_URL: Your LiteLLM proxy URL (default: https://api.thucchien.ai/gemini/v1beta)
  - LITELLM_API_KEY: Your LiteLLM API key (default: sk-1234)
  """
  
  # Configuration from environment or defaults
  base_url = os.getenv("LITELLM_BASE_URL", "https://api.thucchien.ai/gemini/v1beta")
  api_key = os.getenv("LITELLM_API_KEY", "sk-1234")
  
  print("üöÄ Starting Veo Video Generation Example")
  print(f"üì° Using LiteLLM proxy at: {base_url}")
  
  # Initialize generator
  generator = VeoVideoGenerator(base_url=base_url, api_key=api_key)
  
  # Example prompts - try different ones!
  example_prompts = [
      "A cat playing with a ball of yarn in a sunny garden",
      "Ocean waves crashing against rocky cliffs at sunset",
      "A bustling city street with people walking and cars passing by",
      "A peaceful forest with sunlight filtering through the trees"
  ]
  
  # Use first example or get from user
  prompt = example_prompts[0]
  print(f"üé¨ Using prompt: '{prompt}'")
  
  # Generate and download video
  success = generator.generate_and_download(prompt)
  
  if success:
      print("‚úÖ Example completed successfully!")
      print("üí° Try modifying the prompt in the script for different videos!")
  else:
      print("‚ùå Example failed!")
      print("üîß Check your API Configuration")

if __name__ == "__main__":
  main()
```
..............................

[CODE: python_code_2]
```
#!/usr/bin/env python3
"""
Complete example for Veo video generation through LiteLLM proxy.

This script demonstrates how to:
1. Generate videos using Google's Veo model
2. Poll for completion status
3. Download the generated video file

Requirements:
- LiteLLM proxy running with Google AI Studio pass-through configured
- Google AI Studio API key with Veo access

# This file is forked and adapted from: https://github.com/BerriAI/litellm/blob/main/docs/my-website/docs/proxy/veo_video_generation.md .Please refer to the original for license details.
"""

import json
import os
import time
import requests
from typing import Optional


class VeoVideoGenerator:
  """Complete Veo video generation client using LiteLLM proxy."""
  
  def __init__(self, base_url: str = "https://api.thucchien.ai/gemini/v1beta", 
               api_key: str = "sk-1234"):
      """
      Initialize the Veo video generator.
      
      Args:
          base_url: Base URL for the LiteLLM proxy with Gemini pass-through
          api_key: API key for LiteLLM proxy authentication
      """
      self.base_url = base_url
      self.api_key = api_key
      self.headers = {
          "x-goog-api-key": api_key,
          "Content-Type": "application/json"
      }
  
  def generate_video(self, prompt: str) -> Optional[str]:
      """
      Initiate video generation with Veo.
      
      Args:
          prompt: Text description of the video to generate
          
      Returns:
          Operation name if successful, None otherwise
      """
      print(f"üé¨ Generating video with prompt: '{prompt}'")
      
      url = f"{self.base_url}/models/veo-3.0-generate-preview:predictLongRunning"
      payload = {
          "instances": [{
              "prompt": prompt
          }]
      }
      
      try:
          response = requests.post(url, headers=self.headers, json=payload)
          response.raise_for_status()
          
          data = response.json()
          operation_name = data.get("name")
          
          if operation_name:
              print(f"‚úÖ Video generation started: {operation_name}")
              return operation_name
          else:
              print("‚ùå No operation name returned")
              print(f"Response: {json.dumps(data, indent=2)}")
              return None
              
      except requests.RequestException as e:
          print(f"‚ùå Failed to start video generation: {e}")
          if hasattr(e, 'response') and e.response is not None:
              try:
                  error_data = e.response.json()
                  print(f"Error details: {json.dumps(error_data, indent=2)}")
              except:
                  print(f"Error response: {e.response.text}")
          return None
  
  def wait_for_completion(self, operation_name: str, max_wait_time: int = 600) -> Optional[str]:
      """
      Poll operation status until video generation is complete.
      
      Args:
          operation_name: Name of the operation to monitor
          max_wait_time: Maximum time to wait in seconds (default: 10 minutes)
          
      Returns:
          Video URI if successful, None otherwise
      """
      print("‚è≥ Waiting for video generation to complete...")
      
      operation_url = f"{self.base_url}/{operation_name}"
      start_time = time.time()
      poll_interval = 10  # Start with 10 seconds
      
      while time.time() - start_time < max_wait_time:
          try:
              print(f"üîç Polling status... ({int(time.time() - start_time)}s elapsed)")
              
              response = requests.get(operation_url, headers=self.headers)
              response.raise_for_status()
              
              data = response.json()
              
              # Check for errors
              if "error" in data:
                  print("‚ùå Error in video generation:")
                  print(json.dumps(data["error"], indent=2))
                  return None
              
              # Check if operation is complete
              is_done = data.get("done", False)
              
              if is_done:
                  print("üéâ Video generation complete!")
                  
                  try:
                      # Extract video URI from nested response
                      video_uri = data["response"]["generateVideoResponse"]["generatedSamples"][0]["video"]["uri"]
                      print(f"üìπ Video URI: {video_uri}")
                      return video_uri
                  except KeyError as e:
                      print(f"‚ùå Could not extract video URI: {e}")
                      print("Full response:")
                      print(json.dumps(data, indent=2))
                      return None
              
              # Wait before next poll, with exponential backoff
              time.sleep(poll_interval)
              poll_interval = min(poll_interval * 1.2, 30)  # Cap at 30 seconds
              
          except requests.RequestException as e:
              print(f"‚ùå Error polling operation status: {e}")
              time.sleep(poll_interval)
      
      print(f"‚è∞ Timeout after {max_wait_time} seconds")
      return None
  
  def download_video(self, video_uri: str, output_filename: str = "generated_video.mp4") -> bool:
      """
      Download the generated video file.
      
      Args:
          video_uri: URI of the video to download (from Google's response)
          output_filename: Local filename to save the video
          
      Returns:
          True if download successful, False otherwise
      """
      print(f"‚¨áÔ∏è  Downloading video...")
      print(f"Original URI: {video_uri}")
      
      # Convert Google URI to LiteLLM proxy URI
      # Example: https://generativelanguage.googleapis.com/v1beta/files/abc123 -> /gemini/download/v1beta/files/abc123:download?alt=media
      if video_uri.startswith("https://generativelanguage.googleapis.com/"):
          relative_path = video_uri.replace(
              "https://generativelanguage.googleapis.com/",
              ""
          )
      else:
          relative_path = video_uri

      # base_url: https://api.thucchien.ai/gemini/v1beta
      if self.base_url.endswith("/v1beta"):
          base_path = self.base_url.replace("/v1beta", "/download")
      else:
          base_path = self.base_url

      litellm_download_url = f"{base_path}/{relative_path}"
      print(f"Download URL: {litellm_download_url}")
      
      try:
          # Download with streaming and redirect handling
          response = requests.get(
              litellm_download_url, 
              headers=self.headers, 
              stream=True,
              allow_redirects=True  # Handle redirects automatically
          )
          response.raise_for_status()
          
          # Save video file
          with open(output_filename, 'wb') as f:
              downloaded_size = 0
              for chunk in response.iter_content(chunk_size=8192):
                  if chunk:
                      f.write(chunk)
                      downloaded_size += len(chunk)
                      
                      # Progress indicator for large files
                      if downloaded_size % (1024 * 1024) == 0:  # Every MB
                          print(f"üì¶ Downloaded {downloaded_size / (1024*1024):.1f} MB...")
          
          # Verify file was created and has content
          if os.path.exists(output_filename):
              file_size = os.path.getsize(output_filename)
              if file_size > 0:
                  print(f"‚úÖ Video downloaded successfully!")
                  print(f"üìÅ Saved as: {output_filename}")
                  print(f"üìè File size: {file_size / (1024*1024):.2f} MB")
                  return True
              else:
                  print("‚ùå Downloaded file is empty")
                  os.remove(output_filename)
                  return False
          else:
              print("‚ùå File was not created")
              return False
              
      except requests.RequestException as e:
          print(f"‚ùå Download failed: {e}")
          if hasattr(e, 'response') and e.response is not None:
              print(f"Status code: {e.response.status_code}")
              print(f"Response headers: {dict(e.response.headers)}")
          return False
  
  def generate_and_download(self, prompt: str, output_filename: str = None) -> bool:
      """
      Complete workflow: generate video and download it.
      
      Args:
          prompt: Text description for video generation
          output_filename: Output filename (auto-generated if None)
          
      Returns:
          True if successful, False otherwise
      """
      # Auto-generate filename if not provided
      if output_filename is None:
          timestamp = int(time.time())
          safe_prompt = "".join(c for c in prompt[:30] if c.isalnum() or c in (' ', '-', '_')).rstrip()
          output_filename = f"veo_video_{safe_prompt.replace(' ', '_')}_{timestamp}.mp4"
      
      print("=" * 60)
      print("üé¨ VEO VIDEO GENERATION WORKFLOW")
      print("=" * 60)
      
      # Step 1: Generate video
      operation_name = self.generate_video(prompt)
      if not operation_name:
          return False
      
      # Step 2: Wait for completion
      video_uri = self.wait_for_completion(operation_name)
      if not video_uri:
          return False
      
      # Step 3: Download video
      success = self.download_video(video_uri, output_filename)
      
      if success:
          print("=" * 60)
          print("üéâ SUCCESS! Video generation complete!")
          print(f"üìÅ Video saved as: {output_filename}")
          print("=" * 60)
      else:
          print("=" * 60)
          print("‚ùå FAILED! Video generation or download failed")
          print("=" * 60)
      
      return success


def main():
  """
  Example usage of the VeoVideoGenerator.
  
  Configure these environment variables:
  - LITELLM_BASE_URL: Your LiteLLM proxy URL (default: https://api.thucchien.ai/gemini/v1beta)
  - LITELLM_API_KEY: Your LiteLLM API key (default: sk-1234)
  """
  
  # Configuration from environment or defaults
  base_url = os.getenv("LITELLM_BASE_URL", "https://api.thucchien.ai/gemini/v1beta")
  api_key = os.getenv("LITELLM_API_KEY", "sk-1234")
  
  print("üöÄ Starting Veo Video Generation Example")
  print(f"üì° Using LiteLLM proxy at: {base_url}")
  
  # Initialize generator
  generator = VeoVideoGenerator(base_url=base_url, api_key=api_key)
  
  # Example prompts - try different ones!
  example_prompts = [
      "A cat playing with a ball of yarn in a sunny garden",
      "Ocean waves crashing against rocky cliffs at sunset",
      "A bustling city street with people walking and cars passing by",
      "A peaceful forest with sunlight filtering through the trees"
  ]
  
  # Use first example or get from user
  prompt = example_prompts[0]
  print(f"üé¨ Using prompt: '{prompt}'")
  
  # Generate and download video
  success = generator.generate_and_download(prompt)
  
  if success:
      print("‚úÖ Example completed successfully!")
      print("üí° Try modifying the prompt in the script for different videos!")
  else:
      print("‚ùå Example failed!")
      print("üîß Check your API Configuration")

if __name__ == "__main__":
  main()
```
..............................

[CODE: unknown_code_28]
```
#!/usr/bin/env python3
"""
Complete example for Veo video generation through LiteLLM proxy.

This script demonstrates how to:
1. Generate videos using Google's Veo model
2. Poll for completion status
3. Download the generated video file

Requirements:
- LiteLLM proxy running with Google AI Studio pass-through configured
- Google AI Studio API key with Veo access

# This file is forked and adapted from: https://github.com/BerriAI/litellm/blob/main/docs/my-website/docs/proxy/veo_video_generation.md .Please refer to the original for license details.
"""

import json
import os
import time
import requests
from typing import Optional


class VeoVideoGenerator:
  """Complete Veo video generation client using LiteLLM proxy."""
  
  def __init__(self, base_url: str = "https://api.thucchien.ai/gemini/v1beta", 
               api_key: str = "sk-1234"):
      """
      Initialize the Veo video generator.
      
      Args:
          base_url: Base URL for the LiteLLM proxy with Gemini pass-through
          api_key: API key for LiteLLM proxy authentication
      """
      self.base_url = base_url
      self.api_key = api_key
      self.headers = {
          "x-goog-api-key": api_key,
          "Content-Type": "application/json"
      }
  
  def generate_video(self, prompt: str) -> Optional[str]:
      """
      Initiate video generation with Veo.
      
      Args:
          prompt: Text description of the video to generate
          
      Returns:
          Operation name if successful, None otherwise
      """
      print(f"üé¨ Generating video with prompt: '{prompt}'")
      
      url = f"{self.base_url}/models/veo-3.0-generate-preview:predictLongRunning"
      payload = {
          "instances": [{
              "prompt": prompt
          }]
      }
      
      try:
          response = requests.post(url, headers=self.headers, json=payload)
          response.raise_for_status()
          
          data = response.json()
          operation_name = data.get("name")
          
          if operation_name:
              print(f"‚úÖ Video generation started: {operation_name}")
              return operation_name
          else:
              print("‚ùå No operation name returned")
              print(f"Response: {json.dumps(data, indent=2)}")
              return None
              
      except requests.RequestException as e:
          print(f"‚ùå Failed to start video generation: {e}")
          if hasattr(e, 'response') and e.response is not None:
              try:
                  error_data = e.response.json()
                  print(f"Error details: {json.dumps(error_data, indent=2)}")
              except:
                  print(f"Error response: {e.response.text}")
          return None
  
  def wait_for_completion(self, operation_name: str, max_wait_time: int = 600) -> Optional[str]:
      """
      Poll operation status until video generation is complete.
      
      Args:
          operation_name: Name of the operation to monitor
          max_wait_time: Maximum time to wait in seconds (default: 10 minutes)
          
      Returns:
          Video URI if successful, None otherwise
      """
      print("‚è≥ Waiting for video generation to complete...")
      
      operation_url = f"{self.base_url}/{operation_name}"
      start_time = time.time()
      poll_interval = 10  # Start with 10 seconds
      
      while time.time() - start_time < max_wait_time:
          try:
              print(f"üîç Polling status... ({int(time.time() - start_time)}s elapsed)")
              
              response = requests.get(operation_url, headers=self.headers)
              response.raise_for_status()
              
              data = response.json()
              
              # Check for errors
              if "error" in data:
                  print("‚ùå Error in video generation:")
                  print(json.dumps(data["error"], indent=2))
                  return None
              
              # Check if operation is complete
              is_done = data.get("done", False)
              
              if is_done:
                  print("üéâ Video generation complete!")
                  
                  try:
                      # Extract video URI from nested response
                      video_uri = data["response"]["generateVideoResponse"]["generatedSamples"][0]["video"]["uri"]
                      print(f"üìπ Video URI: {video_uri}")
                      return video_uri
                  except KeyError as e:
                      print(f"‚ùå Could not extract video URI: {e}")
                      print("Full response:")
                      print(json.dumps(data, indent=2))
                      return None
              
              # Wait before next poll, with exponential backoff
              time.sleep(poll_interval)
              poll_interval = min(poll_interval * 1.2, 30)  # Cap at 30 seconds
              
          except requests.RequestException as e:
              print(f"‚ùå Error polling operation status: {e}")
              time.sleep(poll_interval)
      
      print(f"‚è∞ Timeout after {max_wait_time} seconds")
      return None
  
  def download_video(self, video_uri: str, output_filename: str = "generated_video.mp4") -> bool:
      """
      Download the generated video file.
      
      Args:
          video_uri: URI of the video to download (from Google's response)
          output_filename: Local filename to save the video
          
      Returns:
          True if download successful, False otherwise
      """
      print(f"‚¨áÔ∏è  Downloading video...")
      print(f"Original URI: {video_uri}")
      
      # Convert Google URI to LiteLLM proxy URI
      # Example: https://generativelanguage.googleapis.com/v1beta/files/abc123 -> /gemini/download/v1beta/files/abc123:download?alt=media
      if video_uri.startswith("https://generativelanguage.googleapis.com/"):
          relative_path = video_uri.replace(
              "https://generativelanguage.googleapis.com/",
              ""
          )
      else:
          relative_path = video_uri

      # base_url: https://api.thucchien.ai/gemini/v1beta
      if self.base_url.endswith("/v1beta"):
          base_path = self.base_url.replace("/v1beta", "/download")
      else:
          base_path = self.base_url

      litellm_download_url = f"{base_path}/{relative_path}"
      print(f"Download URL: {litellm_download_url}")
      
      try:
          # Download with streaming and redirect handling
          response = requests.get(
              litellm_download_url, 
              headers=self.headers, 
              stream=True,
              allow_redirects=True  # Handle redirects automatically
          )
          response.raise_for_status()
          
          # Save video file
          with open(output_filename, 'wb') as f:
              downloaded_size = 0
              for chunk in response.iter_content(chunk_size=8192):
                  if chunk:
                      f.write(chunk)
                      downloaded_size += len(chunk)
                      
                      # Progress indicator for large files
                      if downloaded_size % (1024 * 1024) == 0:  # Every MB
                          print(f"üì¶ Downloaded {downloaded_size / (1024*1024):.1f} MB...")
          
          # Verify file was created and has content
          if os.path.exists(output_filename):
              file_size = os.path.getsize(output_filename)
              if file_size > 0:
                  print(f"‚úÖ Video downloaded successfully!")
                  print(f"üìÅ Saved as: {output_filename}")
                  print(f"üìè File size: {file_size / (1024*1024):.2f} MB")
                  return True
              else:
                  print("‚ùå Downloaded file is empty")
                  os.remove(output_filename)
                  return False
          else:
              print("‚ùå File was not created")
              return False
              
      except requests.RequestException as e:
          print(f"‚ùå Download failed: {e}")
          if hasattr(e, 'response') and e.response is not None:
              print(f"Status code: {e.response.status_code}")
              print(f"Response headers: {dict(e.response.headers)}")
          return False
  
  def generate_and_download(self, prompt: str, output_filename: str = None) -> bool:
      """
      Complete workflow: generate video and download it.
      
      Args:
          prompt: Text description for video generation
          output_filename: Output filename (auto-generated if None)
          
      Returns:
          True if successful, False otherwise
      """
      # Auto-generate filename if not provided
      if output_filename is None:
          timestamp = int(time.time())
          safe_prompt = "".join(c for c in prompt[:30] if c.isalnum() or c in (' ', '-', '_')).rstrip()
          output_filename = f"veo_video_{safe_prompt.replace(' ', '_')}_{timestamp}.mp4"
      
      print("=" * 60)
      print("üé¨ VEO VIDEO GENERATION WORKFLOW")
      print("=" * 60)
      
      # Step 1: Generate video
      operation_name = self.generate_video(prompt)
      if not operation_name:
          return False
      
      # Step 2: Wait for completion
      video_uri = self.wait_for_completion(operation_name)
      if not video_uri:
          return False
      
      # Step 3: Download video
      success = self.download_video(video_uri, output_filename)
      
      if success:
          print("=" * 60)
          print("üéâ SUCCESS! Video generation complete!")
          print(f"üìÅ Video saved as: {output_filename}")
          print("=" * 60)
      else:
          print("=" * 60)
          print("‚ùå FAILED! Video generation or download failed")
          print("=" * 60)
      
      return success


def main():
  """
  Example usage of the VeoVideoGenerator.
  
  Configure these environment variables:
  - LITELLM_BASE_URL: Your LiteLLM proxy URL (default: https://api.thucchien.ai/gemini/v1beta)
  - LITELLM_API_KEY: Your LiteLLM API key (default: sk-1234)
  """
  
  # Configuration from environment or defaults
  base_url = os.getenv("LITELLM_BASE_URL", "https://api.thucchien.ai/gemini/v1beta")
  api_key = os.getenv("LITELLM_API_KEY", "sk-1234")
  
  print("üöÄ Starting Veo Video Generation Example")
  print(f"üì° Using LiteLLM proxy at: {base_url}")
  
  # Initialize generator
  generator = VeoVideoGenerator(base_url=base_url, api_key=api_key)
  
  # Example prompts - try different ones!
  example_prompts = [
      "A cat playing with a ball of yarn in a sunny garden",
      "Ocean waves crashing against rocky cliffs at sunset",
      "A bustling city street with people walking and cars passing by",
      "A peaceful forest with sunlight filtering through the trees"
  ]
  
  # Use first example or get from user
  prompt = example_prompts[0]
  print(f"üé¨ Using prompt: '{prompt}'")
  
  # Generate and download video
  success = generator.generate_and_download(prompt)
  
  if success:
      print("‚úÖ Example completed successfully!")
      print("üí° Try modifying the prompt in the script for different videos!")
  else:
      print("‚ùå Example failed!")
      print("üîß Check your API Configuration")

if __name__ == "__main__":
  main()
```
..............................

FULL CONTENT:
----------------------------------------
H∆∞·ªõng d·∫´n s·ª≠ d·ª•ng APISinh video v·ªõi Veo 3 (Quy tr√¨nh b·∫•t ƒë·ªìng b·ªô)
Sinh video v·ªõi Veo 3 (Quy tr√¨nh b·∫•t ƒë·ªìng b·ªô)
Vi·ªác t·∫°o video l√† m·ªôt t√°c v·ª• t·ªën nhi·ªÅu t√†i nguy√™n v√† th·ªùi gian. Do ƒë√≥, t∆∞∆°ng t√°c v·ªõi m√¥ h√¨nh veo 3 kh√¥ng di·ªÖn ra ngay l·∫≠p t·ª©c m√† theo m·ªôt quy tr√¨nh b·∫•t ƒë·ªìng b·ªô (asynchronous) g·ªìm 3 b∆∞·ªõc.
Model ƒë∆∞·ª£c h·ªó tr·ª£: veo 3 (Google Vertex AI)
T·ªïng quan quy tr√¨nh
B·∫Øt ƒë·∫ßu t√°c v·ª•: B·∫°n g·ª≠i m·ªôt y√™u c·∫ßu ch·ª©a m√¥ t·∫£ (prompt) ƒë·ªÉ b·∫Øt ƒë·∫ßu qu√° tr√¨nh t·∫°o video. API s·∫Ω tr·∫£ v·ªÅ m·ªôt operation_name ƒë·ªÉ b·∫°n theo d√µi.
Ki·ªÉm tra tr·∫°ng th√°i: B·∫°n s·ª≠ d·ª•ng operation_name ƒë·ªÉ h·ªèi API xem video ƒë√£ ƒë∆∞·ª£c t·∫°o xong ch∆∞a. B·∫°n c·∫ßn l·∫∑p l·∫°i b∆∞·ªõc n√†y cho ƒë·∫øn khi nh·∫≠n ƒë∆∞·ª£c tr·∫°ng th√°i ho√†n t·∫•t.
T·∫£i video: Khi video ƒë√£ s·∫µn s√†ng, k·∫øt qu·∫£ ki·ªÉm tra tr·∫°ng th√°i s·∫Ω ch·ª©a m·ªôt URI (ƒë∆∞·ªùng d·∫´n) ƒë·∫øn file video. B·∫°n s·ª≠ d·ª•ng URI n√†y ƒë·ªÉ t·∫£i video v·ªÅ.
H∆∞·ªõng d·∫´n chi ti·∫øt
curl (T·ª´ng b∆∞·ªõc)
Python (Script t·ª± ƒë·ªông)
B∆∞·ªõc 1: B·∫Øt ƒë·∫ßu t·∫°o video
G·ª≠i m·ªôt y√™u c·∫ßu POST ƒë·∫øn endpoint ƒë·∫∑c bi·ªát d√†nh cho Veo.
QUAN TR·ªåNG
Do m√°y ch·ªß proxy ƒëang s·ª≠ d·ª•ng c∆° ch·∫ø pass-through t·ªõi Google AI Studio, b·∫°n s·∫Ω s·ª≠ d·ª•ng header x-goog-api-key thay cho header Authorization ti√™u chu·∫©n.
curl -X POST https://api.thucchien.ai/gemini/v1beta/models/veo-3.0-generate-preview:predictLongRunning \
-H "Content-Type: application/json" \
-H "x-goog-api-key: <your_api_key>" \
-d '{
  "instances": [{
    "prompt": "A cinematic shot of a hummingbird flying in slow motion"
  }]
}'
N·∫øu th√†nh c√¥ng, API s·∫Ω tr·∫£ v·ªÅ m·ªôt JSON ch·ª©a name c·ªßa t√°c v·ª•. H√£y l∆∞u l·∫°i gi√° tr·ªã n√†y.
{
"name": "models/veo-3.0-generate-preview/operations/idrk08ltkg0a"
}
Trong ƒë√≥:
operation_name: l√† to√†n b·ªô chu·ªói models/veo-3.0-generate-preview/operations/idrk08ltkg0a.
operation_id: l√† ph·∫ßn ƒë·ªãnh danh duy nh·∫•t c·ªßa t√°c v·ª•, trong v√≠ d·ª• n√†y l√† idrk08ltkg0a. B·∫°n s·∫Ω s·ª≠ d·ª•ng ID n√†y ·ªü b∆∞·ªõc ti·∫øp theo.
B∆∞·ªõc 2: Ki·ªÉm tra tr·∫°ng th√°i
S·ª≠ d·ª•ng operation_id (v√≠ d·ª•: idrk08ltkg0a) b·∫°n nh·∫≠n ƒë∆∞·ª£c ·ªü B∆∞·ªõc 1 ƒë·ªÉ x√¢y d·ª±ng URL v√† g·ª≠i y√™u c·∫ßu GET ƒë·ªÉ ki·ªÉm tra tr·∫°ng th√°i.
# URL ki·ªÉm tra tr·∫°ng th√°i: https://api.thucchien.ai/gemini/v1beta/models/veo-3.0-generate-preview/operations/idrk08ltkg0a
curl https://api.thucchien.ai/gemini/v1beta/models/veo-3.0-generate-preview/operations/<operation_id> \
-H "x-goog-api-key: <your_api_key>"
L·∫∑p l·∫°i y√™u c·∫ßu n√†y cho ƒë·∫øn khi response ch·ª©a "done": true.
{
  "name": "models/veo-3.0-generate-preview/operations/idrk08ltkg0a",
  "done": true,
  "response": {
      "@type": "type.googleapis.com/google.ai.generativelanguage.v1beta.PredictLongRunningResponse",
      "generateVideoResponse": {
          "generatedSamples": [
              {
                  "video": {
                      "uri": "https://generativelanguage.googleapis.com/v1beta/files/3j6svp4106e7:download?alt=media"
                  }
              }
          ]
      }
  }
}
Khi t√°c v·ª• ho√†n t·∫•t ("done": true), response s·∫Ω ch·ª©a m·ªôt tr∆∞·ªùng uri. T·ª´ URI n√†y, ch√∫ng ta c√≥ th·ªÉ tr√≠ch xu·∫•t ra video_id, trong tr∆∞·ªùng h·ª£p n√†y l√† 3j6svp4106e7. ID n√†y ƒë∆∞·ª£c d√πng ƒë·ªÉ t·∫£i video ·ªü b∆∞·ªõc cu·ªëi c√πng.
B∆∞·ªõc 3: T·∫£i video
S·ª≠ d·ª•ng video_id (v√≠ d·ª•: 3j6svp4106e7) ƒë√£ tr√≠ch xu·∫•t ·ªü B∆∞·ªõc 2 ƒë·ªÉ t·∫°o URL t·∫£i xu·ªëng cu·ªëi c√πng th√¥ng qua proxy.
# URI g·ªëc t·ª´ Google: https://generativelanguage.googleapis.com/v1beta/files/3j6svp4106e7:download?alt=media
# ƒê∆∞·ªùng d·∫´n t∆∞∆°ng ƒë·ªëi c·∫ßn d√πng: v1beta/files/3j6svp4106e7:download?alt=media
# URL t·∫£i xu·ªëng qua proxy: https://api.thucchien.ai/gemini/download/v1beta/files/3j6svp4106e7:download?alt=media

curl https://api.thucchien.ai/gemini/download/v1beta/files/<video_id>:download?alt=media \
-H "x-goog-api-key: <your_api_key>" \
--output my_generated_video.mp4
K·∫øt qu·∫£ b·∫°n s·∫Ω c√≥ file video nh∆∞ sau:
Your browser does not support the video tag.


























































































































































































































































































































C√°c tham s·ªë t√πy ch·ªçn
Ngo√†i prompt, b·∫°n c√≥ th·ªÉ ch·ªâ ƒë·ªãnh th√™m c√°c tham s·ªë kh√°c trong body c·ªßa y√™u c·∫ßu ·ªü B∆∞·ªõc 1 ƒë·ªÉ ki·ªÉm so√°t video ƒë∆∞·ª£c t·∫°o ra, v√≠ d·ª• nh∆∞ th·ªùi l∆∞·ª£ng, ch·∫•t l∆∞·ª£ng, v.v.
ƒê·ªÉ bi·∫øt danh s√°ch ƒë·∫ßy ƒë·ªß c√°c tham s·ªë v√† c√°ch s·ª≠ d·ª•ng, vui l√≤ng tham kh·∫£o t√†i li·ªáu ch√≠nh th·ª©c t·∫°i ƒë√¢y: Google AI for Developers - Video Generation.
Previous
Sinh h√¨nh ·∫£nh (Image Generation)
Next
Chuy·ªÉn vƒÉn b·∫£n th√†nh gi·ªçng n√≥i (Text-to-Speech)
T·ªïng quan quy tr√¨nh
H∆∞·ªõng d·∫´n chi ti·∫øt
C√°c tham s·ªë t√πy ch·ªçn

=== TAB CONTENT ===

--- curl (T·ª´ng b∆∞·ªõc)_0 ---
curl -X POST https://api.thucchien.ai/gemini/v1beta/models/veo-3.0-generate-preview:predictLongRunning \
-H "Content-Type: application/json" \
-H "x-goog-api-key: <your_api_key>" \
-d '{
  "instances": [{
    "prompt": "A cinematic shot of a hummingbird flying in slow motion"
  }]
}'

--- Python (Script t·ª± ƒë·ªông)_1 ---
#!/usr/bin/env python3
"""
Complete example for Veo video generation through LiteLLM proxy.

This script demonstrates how to:
1. Generate videos using Google's Veo model
2. Poll for completion status
3. Download the generated video file

Requirements:
- LiteLLM proxy running with Google AI Studio pass-through configured
- Google AI Studio API key with Veo access

# This file is forked and adapted from: https://github.com/BerriAI/litellm/blob/main/docs/my-website/docs/proxy/veo_video_generation.md .Please refer to the original for license details.
"""

import json
import os
import time
import requests
from typing import Optional


class VeoVideoGenerator:
  """Complete Veo video generation client using LiteLLM proxy."""
  
  def __init__(self, base_url: str = "https://api.thucchien.ai/gemini/v1beta", 
               api_key: str = "sk-1234"):
      """
      Initialize the Veo video generator.
      
      Args:
          base_url: Base URL for the LiteLLM proxy with Gemini pass-through
          api_key: API key for LiteLLM proxy authentication
      """
      self.base_url = base_url
      self.api_key = api_key
      self.headers = {
          "x-goog-api-key": api_key,
          "Content-Type": "application/json"
      }
  
  def generate_video(self, prompt: str) -> Optional[str]:
      """
      Initiate video generation with Veo.
      
      Args:
          prompt: Text description of the video to generate
          
      Returns:
          Operation name if successful, None otherwise
      """
      print(f"üé¨ Generating video with prompt: '{prompt}'")
      
      url = f"{self.base_url}/models/veo-3.0-generate-preview:predictLongRunning"
      payload = {
          "instances": [{
              "prompt": prompt
          }]
      }
      
      try:
          response = requests.post(url, headers=self.headers, json=payload)
          response.raise_for_status()
          
          data = response.json()
          operation_name = data.get("name")
          
          if operation_name:
              print(f"‚úÖ Video generation started: {operation_name}")
              return operation_name
          else:
              print("‚ùå No operation name returned")
              print(f"Response: {json.dumps(data, indent=2)}")
              return None
              
      except requests.RequestException as e:
          print(f"‚ùå Failed to start video generation: {e}")
          if hasattr(e, 'response') and e.response is not None:
              try:
                  error_data = e.response.json()
                  print(f"Error details: {json.dumps(error_data, indent=2)}")
              except:
                  print(f"Error response: {e.response.text}")
          return None
  
  def wait_for_completion(self, operation_name: str, max_wait_time: int = 600) -> Optional[str]:
      """
      Poll operation status until video generation is complete.
      
      Args:
          operation_name: Name of the operation to monitor
          max_wait_time: Maximum time to wait in seconds (default: 10 minutes)
          
      Returns:
          Video URI if successful, None otherwise
      """
      print("‚è≥ Waiting for video generation to complete...")
      
      operation_url = f"{self.base_url}/{operation_name}"
      start_time = time.time()
      poll_interval = 10  # Start with 10 seconds
      
      while time.time() - start_time < max_wait_time:
          try:
              print(f"üîç Polling status... ({int(time.time() - start_time)}s elapsed)")
              
              response = requests.get(operation_url, headers=self.headers)
              response.raise_for_status()
              
              data = response.json()
              
              # Check for errors
              if "error" in data:
                  print("‚ùå Error in video generation:")
                  print(json.dumps(data["error"], indent=2))
                  return None
              
              # Check if operation is complete
              is_done = data.get("done", False)
              
              if is_done:
                  print("üéâ Video generation complete!")
                  
                  try:
                      # Extract video URI from nested response
                      video_uri = data["response"]["generateVideoResponse"]["generatedSamples"][0]["video"]["uri"]
                      print(f"üìπ Video URI: {video_uri}")
                      return video_uri
                  except KeyError as e:
                      print(f"‚ùå Could not extract video URI: {e}")
                      print("Full response:")
                      print(json.dumps(data, indent=2))
                      return None
              
              # Wait before next poll, with exponential backoff
              time.sleep(poll_interval)
              poll_interval = min(poll_interval * 1.2, 30)  # Cap at 30 seconds
              
          except requests.RequestException as e:
              print(f"‚ùå Error polling operation status: {e}")
              time.sleep(poll_interval)
      
      print(f"‚è∞ Timeout after {max_wait_time} seconds")
      return None
  
  def download_video(self, video_uri: str, output_filename: str = "generated_video.mp4") -> bool:
      """
      Download the generated video file.
      
      Args:
          video_uri: URI of the video to download (from Google's response)
          output_filename: Local filename to save the video
          
      Returns:
          True if download successful, False otherwise
      """
      print(f"‚¨áÔ∏è  Downloading video...")
      print(f"Original URI: {video_uri}")
      
      # Convert Google URI to LiteLLM proxy URI
      # Example: https://generativelanguage.googleapis.com/v1beta/files/abc123 -> /gemini/download/v1beta/files/abc123:download?alt=media
      if video_uri.startswith("https://generativelanguage.googleapis.com/"):
          relative_path = video_uri.replace(
              "https://generativelanguage.googleapis.com/",
              ""
          )
      else:
          relative_path = video_uri

      # base_url: https://api.thucchien.ai/gemini/v1beta
      if self.base_url.endswith("/v1beta"):
          base_path = self.base_url.replace("/v1beta", "/download")
      else:
          base_path = self.base_url

      litellm_download_url = f"{base_path}/{relative_path}"
      print(f"Download URL: {litellm_download_url}")
      
      try:
          # Download with streaming and redirect handling
          response = requests.get(
              litellm_download_url, 
              headers=self.headers, 
              stream=True,
              allow_redirects=True  # Handle redirects automatically
          )
          response.raise_for_status()
          
          # Save video file
          with open(output_filename, 'wb') as f:
              downloaded_size = 0
              for chunk in response.iter_content(chunk_size=8192):
                  if chunk:
                      f.write(chunk)
                      downloaded_size += len(chunk)
                      
                      # Progress indicator for large files
                      if downloaded_size % (1024 * 1024) == 0:  # Every MB
                          print(f"üì¶ Downloaded {downloaded_size / (1024*1024):.1f} MB...")
          
          # Verify file was created and has content
          if os.path.exists(output_filename):
              file_size = os.path.getsize(output_filename)
              if file_size > 0:
                  print(f"‚úÖ Video downloaded successfully!")
                  print(f"üìÅ Saved as: {output_filename}")
                  print(f"üìè File size: {file_size / (1024*1024):.2f} MB")
                  return True
              else:
                  print("‚ùå Downloaded file is empty")
                  os.remove(output_filename)
                  return False
          else:
              print("‚ùå File was not created")
              return False
              
      except requests.RequestException as e:
          print(f"‚ùå Download failed: {e}")
          if hasattr(e, 'response') and e.response is not None:
              print(f"Status code: {e.response.status_code}")
              print(f"Response headers: {dict(e.response.headers)}")
          return False
  
  def generate_and_download(self, prompt: str, output_filename: str = None) -> bool:
      """
      Complete workflow: generate video and download it.
      
      Args:
          prompt: Text description for video generation
          output_filename: Output filename (auto-generated if None)
          
      Returns:
          True if successful, False otherwise
      """
      # Auto-generate filename if not provided
      if output_filename is None:
          timestamp = int(time.time())
          safe_prompt = "".join(c for c in prompt[:30] if c.isalnum() or c in (' ', '-', '_')).rstrip()
          output_filename = f"veo_video_{safe_prompt.replace(' ', '_')}_{timestamp}.mp4"
      
      print("=" * 60)
      print("üé¨ VEO VIDEO GENERATION WORKFLOW")
      print("=" * 60)
      
      # Step 1: Generate video
      operation_name = self.generate_video(prompt)
      if not operation_name:
          return False
      
      # Step 2: Wait for completion
      video_uri = self.wait_for_completion(operation_name)
      if not video_uri:
          return False
      
      # Step 3: Download video
      success = self.download_video(video_uri, output_filename)
      
      if success:
          print("=" * 60)
          print("üéâ SUCCESS! Video generation complete!")
          print(f"üìÅ Video saved as: {output_filename}")
          print("=" * 60)
      else:
          print("=" * 60)
          print("‚ùå FAILED! Video generation or download failed")
          print("=" * 60)
      
      return success


def main():
  """
  Example usage of the VeoVideoGenerator.
  
  Configure these environment variables:
  - LITELLM_BASE_URL: Your LiteLLM proxy URL (default: https://api.thucchien.ai/gemini/v1beta)
  - LITELLM_API_KEY: Your LiteLLM API key (default: sk-1234)
  """
  
  # Configuration from environment or defaults
  base_url = os.getenv("LITELLM_BASE_URL", "https://api.thucchien.ai/gemini/v1beta")
  api_key = os.getenv("LITELLM_API_KEY", "sk-1234")
  
  print("üöÄ Starting Veo Video Generation Example")
  print(f"üì° Using LiteLLM proxy at: {base_url}")
  
  # Initialize generator
  generator = VeoVideoGenerator(base_url=base_url, api_key=api_key)
  
  # Example prompts - try different ones!
  example_prompts = [
      "A cat playing with a ball of yarn in a sunny garden",
      "Ocean waves crashing against rocky cliffs at sunset",
      "A bustling city street with people walking and cars passing by",
      "A peaceful forest with sunlight filtering through the trees"
  ]
  
  # Use first example or get from user
  prompt = example_prompts[0]
  print(f"üé¨ Using prompt: '{prompt}'")
  
  # Generate and download video
  success = generator.generate_and_download(prompt)
  
  if success:
      print("‚úÖ Example completed successfully!")
      print("üí° Try modifying the prompt in the script for different videos!")
  else:
      print("‚ùå Example failed!")
      print("üîß Check your API Configuration")

if __name__ == "__main__":
  main()


=== CODE BLOCKS ===

--- unknown_code_6 ---
#!/usr/bin/env python3
"""
Complete example for Veo video generation through LiteLLM proxy.

This script demonstrates how to:
1. Generate videos using Google's Veo model
2. Poll for completion status
3. Download the generated video file

Requirements:
- LiteLLM proxy running with Google AI Studio pass-through configured
- Google AI Studio API key with Veo access

# This file is forked and adapted from: https://github.com/BerriAI/litellm/blob/main/docs/my-website/docs/proxy/veo_video_generation.md .Please refer to the original for license details.
"""

import json
import os
import time
import requests
from typing import Optional


class VeoVideoGenerator:
  """Complete Veo video generation client using LiteLLM proxy."""
  
  def __init__(self, base_url: str = "https://api.thucchien.ai/gemini/v1beta", 
               api_key: str = "sk-1234"):
      """
      Initialize the Veo video generator.
      
      Args:
          base_url: Base URL for the LiteLLM proxy with Gemini pass-through
          api_key: API key for LiteLLM proxy authentication
      """
      self.base_url = base_url
      self.api_key = api_key
      self.headers = {
          "x-goog-api-key": api_key,
          "Content-Type": "application/json"
      }
  
  def generate_video(self, prompt: str) -> Optional[str]:
      """
      Initiate video generation with Veo.
      
      Args:
          prompt: Text description of the video to generate
          
      Returns:
          Operation name if successful, None otherwise
      """
      print(f"üé¨ Generating video with prompt: '{prompt}'")
      
      url = f"{self.base_url}/models/veo-3.0-generate-preview:predictLongRunning"
      payload = {
          "instances": [{
              "prompt": prompt
          }]
      }
      
      try:
          response = requests.post(url, headers=self.headers, json=payload)
          response.raise_for_status()
          
          data = response.json()
          operation_name = data.get("name")
          
          if operation_name:
              print(f"‚úÖ Video generation started: {operation_name}")
              return operation_name
          else:
              print("‚ùå No operation name returned")
              print(f"Response: {json.dumps(data, indent=2)}")
              return None
              
      except requests.RequestException as e:
          print(f"‚ùå Failed to start video generation: {e}")
          if hasattr(e, 'response') and e.response is not None:
              try:
                  error_data = e.response.json()
                  print(f"Error details: {json.dumps(error_data, indent=2)}")
              except:
                  print(f"Error response: {e.response.text}")
          return None
  
  def wait_for_completion(self, operation_name: str, max_wait_time: int = 600) -> Optional[str]:
      """
      Poll operation status until video generation is complete.
      
      Args:
          operation_name: Name of the operation to monitor
          max_wait_time: Maximum time to wait in seconds (default: 10 minutes)
          
      Returns:
          Video URI if successful, None otherwise
      """
      print("‚è≥ Waiting for video generation to complete...")
      
      operation_url = f"{self.base_url}/{operation_name}"
      start_time = time.time()
      poll_interval = 10  # Start with 10 seconds
      
      while time.time() - start_time < max_wait_time:
          try:
              print(f"üîç Polling status... ({int(time.time() - start_time)}s elapsed)")
              
              response = requests.get(operation_url, headers=self.headers)
              response.raise_for_status()
              
              data = response.json()
              
              # Check for errors
              if "error" in data:
                  print("‚ùå Error in video generation:")
                  print(json.dumps(data["error"], indent=2))
                  return None
              
              # Check if operation is complete
              is_done = data.get("done", False)
              
              if is_done:
                  print("üéâ Video generation complete!")
                  
                  try:
                      # Extract video URI from nested response
                      video_uri = data["response"]["generateVideoResponse"]["generatedSamples"][0]["video"]["uri"]
                      print(f"üìπ Video URI: {video_uri}")
                      return video_uri
                  except KeyError as e:
                      print(f"‚ùå Could not extract video URI: {e}")
                      print("Full response:")
                      print(json.dumps(data, indent=2))
                      return None
              
              # Wait before next poll, with exponential backoff
              time.sleep(poll_interval)
              poll_interval = min(poll_interval * 1.2, 30)  # Cap at 30 seconds
              
          except requests.RequestException as e:
              print(f"‚ùå Error polling operation status: {e}")
              time.sleep(poll_interval)
      
      print(f"‚è∞ Timeout after {max_wait_time} seconds")
      return None
  
  def download_video(self, video_uri: str, output_filename: str = "generated_video.mp4") -> bool:
      """
      Download the generated video file.
      
      Args:
          video_uri: URI of the video to download (from Google's response)
          output_filename: Local filename to save the video
          
      Returns:
          True if download successful, False otherwise
      """
      print(f"‚¨áÔ∏è  Downloading video...")
      print(f"Original URI: {video_uri}")
      
      # Convert Google URI to LiteLLM proxy URI
      # Example: https://generativelanguage.googleapis.com/v1beta/files/abc123 -> /gemini/download/v1beta/files/abc123:download?alt=media
      if video_uri.startswith("https://generativelanguage.googleapis.com/"):
          relative_path = video_uri.replace(
              "https://generativelanguage.googleapis.com/",
              ""
          )
      else:
          relative_path = video_uri

      # base_url: https://api.thucchien.ai/gemini/v1beta
      if self.base_url.endswith("/v1beta"):
          base_path = self.base_url.replace("/v1beta", "/download")
      else:
          base_path = self.base_url

      litellm_download_url = f"{base_path}/{relative_path}"
      print(f"Download URL: {litellm_download_url}")
      
      try:
          # Download with streaming and redirect handling
          response = requests.get(
              litellm_download_url, 
              headers=self.headers, 
              stream=True,
              allow_redirects=True  # Handle redirects automatically
          )
          response.raise_for_status()
          
          # Save video file
          with open(output_filename, 'wb') as f:
              downloaded_size = 0
              for chunk in response.iter_content(chunk_size=8192):
                  if chunk:
                      f.write(chunk)
                      downloaded_size += len(chunk)
                      
                      # Progress indicator for large files
                      if downloaded_size % (1024 * 1024) == 0:  # Every MB
                          print(f"üì¶ Downloaded {downloaded_size / (1024*1024):.1f} MB...")
          
          # Verify file was created and has content
          if os.path.exists(output_filename):
              file_size = os.path.getsize(output_filename)
              if file_size > 0:
                  print(f"‚úÖ Video downloaded successfully!")
                  print(f"üìÅ Saved as: {output_filename}")
                  print(f"üìè File size: {file_size / (1024*1024):.2f} MB")
                  return True
              else:
                  print("‚ùå Downloaded file is empty")
                  os.remove(output_filename)
                  return False
          else:
              print("‚ùå File was not created")
              return False
              
      except requests.RequestException as e:
          print(f"‚ùå Download failed: {e}")
          if hasattr(e, 'response') and e.response is not None:
              print(f"Status code: {e.response.status_code}")
              print(f"Response headers: {dict(e.response.headers)}")
          return False
  
  def generate_and_download(self, prompt: str, output_filename: str = None) -> bool:
      """
      Complete workflow: generate video and download it.
      
      Args:
          prompt: Text description for video generation
          output_filename: Output filename (auto-generated if None)
          
      Returns:
          True if successful, False otherwise
      """
      # Auto-generate filename if not provided
      if output_filename is None:
          timestamp = int(time.time())
          safe_prompt = "".join(c for c in prompt[:30] if c.isalnum() or c in (' ', '-', '_')).rstrip()
          output_filename = f"veo_video_{safe_prompt.replace(' ', '_')}_{timestamp}.mp4"
      
      print("=" * 60)
      print("üé¨ VEO VIDEO GENERATION WORKFLOW")
      print("=" * 60)
      
      # Step 1: Generate video
      operation_name = self.generate_video(prompt)
      if not operation_name:
          return False
      
      # Step 2: Wait for completion
      video_uri = self.wait_for_completion(operation_name)
      if not video_uri:
          return False
      
      # Step 3: Download video
      success = self.download_video(video_uri, output_filename)
      
      if success:
          print("=" * 60)
          print("üéâ SUCCESS! Video generation complete!")
          print(f"üìÅ Video saved as: {output_filename}")
          print("=" * 60)
      else:
          print("=" * 60)
          print("‚ùå FAILED! Video generation or download failed")
          print("=" * 60)
      
      return success


def main():
  """
  Example usage of the VeoVideoGenerator.
  
  Configure these environment variables:
  - LITELLM_BASE_URL: Your LiteLLM proxy URL (default: https://api.thucchien.ai/gemini/v1beta)
  - LITELLM_API_KEY: Your LiteLLM API key (default: sk-1234)
  """
  
  # Configuration from environment or defaults
  base_url = os.getenv("LITELLM_BASE_URL", "https://api.thucchien.ai/gemini/v1beta")
  api_key = os.getenv("LITELLM_API_KEY", "sk-1234")
  
  print("üöÄ Starting Veo Video Generation Example")
  print(f"üì° Using LiteLLM proxy at: {base_url}")
  
  # Initialize generator
  generator = VeoVideoGenerator(base_url=base_url, api_key=api_key)
  
  # Example prompts - try different ones!
  example_prompts = [
      "A cat playing with a ball of yarn in a sunny garden",
      "Ocean waves crashing against rocky cliffs at sunset",
      "A bustling city street with people walking and cars passing by",
      "A peaceful forest with sunlight filtering through the trees"
  ]
  
  # Use first example or get from user
  prompt = example_prompts[0]
  print(f"üé¨ Using prompt: '{prompt}'")
  
  # Generate and download video
  success = generator.generate_and_download(prompt)
  
  if success:
      print("‚úÖ Example completed successfully!")
      print("üí° Try modifying the prompt in the script for different videos!")
  else:
      print("‚ùå Example failed!")
      print("üîß Check your API Configuration")

if __name__ == "__main__":
  main()

--- python_code_1 ---
#!/usr/bin/env python3
"""
Complete example for Veo video generation through LiteLLM proxy.

This script demonstrates how to:
1. Generate videos using Google's Veo model
2. Poll for completion status
3. Download the generated video file

Requirements:
- LiteLLM proxy running with Google AI Studio pass-through configured
- Google AI Studio API key with Veo access

# This file is forked and adapted from: https://github.com/BerriAI/litellm/blob/main/docs/my-website/docs/proxy/veo_video_generation.md .Please refer to the original for license details.
"""

import json
import os
import time
import requests
from typing import Optional


class VeoVideoGenerator:
  """Complete Veo video generation client using LiteLLM proxy."""
  
  def __init__(self, base_url: str = "https://api.thucchien.ai/gemini/v1beta", 
               api_key: str = "sk-1234"):
      """
      Initialize the Veo video generator.
      
      Args:
          base_url: Base URL for the LiteLLM proxy with Gemini pass-through
          api_key: API key for LiteLLM proxy authentication
      """
      self.base_url = base_url
      self.api_key = api_key
      self.headers = {
          "x-goog-api-key": api_key,
          "Content-Type": "application/json"
      }
  
  def generate_video(self, prompt: str) -> Optional[str]:
      """
      Initiate video generation with Veo.
      
      Args:
          prompt: Text description of the video to generate
          
      Returns:
          Operation name if successful, None otherwise
      """
      print(f"üé¨ Generating video with prompt: '{prompt}'")
      
      url = f"{self.base_url}/models/veo-3.0-generate-preview:predictLongRunning"
      payload = {
          "instances": [{
              "prompt": prompt
          }]
      }
      
      try:
          response = requests.post(url, headers=self.headers, json=payload)
          response.raise_for_status()
          
          data = response.json()
          operation_name = data.get("name")
          
          if operation_name:
              print(f"‚úÖ Video generation started: {operation_name}")
              return operation_name
          else:
              print("‚ùå No operation name returned")
              print(f"Response: {json.dumps(data, indent=2)}")
              return None
              
      except requests.RequestException as e:
          print(f"‚ùå Failed to start video generation: {e}")
          if hasattr(e, 'response') and e.response is not None:
              try:
                  error_data = e.response.json()
                  print(f"Error details: {json.dumps(error_data, indent=2)}")
              except:
                  print(f"Error response: {e.response.text}")
          return None
  
  def wait_for_completion(self, operation_name: str, max_wait_time: int = 600) -> Optional[str]:
      """
      Poll operation status until video generation is complete.
      
      Args:
          operation_name: Name of the operation to monitor
          max_wait_time: Maximum time to wait in seconds (default: 10 minutes)
          
      Returns:
          Video URI if successful, None otherwise
      """
      print("‚è≥ Waiting for video generation to complete...")
      
      operation_url = f"{self.base_url}/{operation_name}"
      start_time = time.time()
      poll_interval = 10  # Start with 10 seconds
      
      while time.time() - start_time < max_wait_time:
          try:
              print(f"üîç Polling status... ({int(time.time() - start_time)}s elapsed)")
              
              response = requests.get(operation_url, headers=self.headers)
              response.raise_for_status()
              
              data = response.json()
              
              # Check for errors
              if "error" in data:
                  print("‚ùå Error in video generation:")
                  print(json.dumps(data["error"], indent=2))
                  return None
              
              # Check if operation is complete
              is_done = data.get("done", False)
              
              if is_done:
                  print("üéâ Video generation complete!")
                  
                  try:
                      # Extract video URI from nested response
                      video_uri = data["response"]["generateVideoResponse"]["generatedSamples"][0]["video"]["uri"]
                      print(f"üìπ Video URI: {video_uri}")
                      return video_uri
                  except KeyError as e:
                      print(f"‚ùå Could not extract video URI: {e}")
                      print("Full response:")
                      print(json.dumps(data, indent=2))
                      return None
              
              # Wait before next poll, with exponential backoff
              time.sleep(poll_interval)
              poll_interval = min(poll_interval * 1.2, 30)  # Cap at 30 seconds
              
          except requests.RequestException as e:
              print(f"‚ùå Error polling operation status: {e}")
              time.sleep(poll_interval)
      
      print(f"‚è∞ Timeout after {max_wait_time} seconds")
      return None
  
  def download_video(self, video_uri: str, output_filename: str = "generated_video.mp4") -> bool:
      """
      Download the generated video file.
      
      Args:
          video_uri: URI of the video to download (from Google's response)
          output_filename: Local filename to save the video
          
      Returns:
          True if download successful, False otherwise
      """
      print(f"‚¨áÔ∏è  Downloading video...")
      print(f"Original URI: {video_uri}")
      
      # Convert Google URI to LiteLLM proxy URI
      # Example: https://generativelanguage.googleapis.com/v1beta/files/abc123 -> /gemini/download/v1beta/files/abc123:download?alt=media
      if video_uri.startswith("https://generativelanguage.googleapis.com/"):
          relative_path = video_uri.replace(
              "https://generativelanguage.googleapis.com/",
              ""
          )
      else:
          relative_path = video_uri

      # base_url: https://api.thucchien.ai/gemini/v1beta
      if self.base_url.endswith("/v1beta"):
          base_path = self.base_url.replace("/v1beta", "/download")
      else:
          base_path = self.base_url

      litellm_download_url = f"{base_path}/{relative_path}"
      print(f"Download URL: {litellm_download_url}")
      
      try:
          # Download with streaming and redirect handling
          response = requests.get(
              litellm_download_url, 
              headers=self.headers, 
              stream=True,
              allow_redirects=True  # Handle redirects automatically
          )
          response.raise_for_status()
          
          # Save video file
          with open(output_filename, 'wb') as f:
              downloaded_size = 0
              for chunk in response.iter_content(chunk_size=8192):
                  if chunk:
                      f.write(chunk)
                      downloaded_size += len(chunk)
                      
                      # Progress indicator for large files
                      if downloaded_size % (1024 * 1024) == 0:  # Every MB
                          print(f"üì¶ Downloaded {downloaded_size / (1024*1024):.1f} MB...")
          
          # Verify file was created and has content
          if os.path.exists(output_filename):
              file_size = os.path.getsize(output_filename)
              if file_size > 0:
                  print(f"‚úÖ Video downloaded successfully!")
                  print(f"üìÅ Saved as: {output_filename}")
                  print(f"üìè File size: {file_size / (1024*1024):.2f} MB")
                  return True
              else:
                  print("‚ùå Downloaded file is empty")
                  os.remove(output_filename)
                  return False
          else:
              print("‚ùå File was not created")
              return False
              
      except requests.RequestException as e:
          print(f"‚ùå Download failed: {e}")
          if hasattr(e, 'response') and e.response is not None:
              print(f"Status code: {e.response.status_code}")
              print(f"Response headers: {dict(e.response.headers)}")
          return False
  
  def generate_and_download(self, prompt: str, output_filename: str = None) -> bool:
      """
      Complete workflow: generate video and download it.
      
      Args:
          prompt: Text description for video generation
          output_filename: Output filename (auto-generated if None)
          
      Returns:
          True if successful, False otherwise
      """
      # Auto-generate filename if not provided
      if output_filename is None:
          timestamp = int(time.time())
          safe_prompt = "".join(c for c in prompt[:30] if c.isalnum() or c in (' ', '-', '_')).rstrip()
          output_filename = f"veo_video_{safe_prompt.replace(' ', '_')}_{timestamp}.mp4"
      
      print("=" * 60)
      print("üé¨ VEO VIDEO GENERATION WORKFLOW")
      print("=" * 60)
      
      # Step 1: Generate video
      operation_name = self.generate_video(prompt)
      if not operation_name:
          return False
      
      # Step 2: Wait for completion
      video_uri = self.wait_for_completion(operation_name)
      if not video_uri:
          return False
      
      # Step 3: Download video
      success = self.download_video(video_uri, output_filename)
      
      if success:
          print("=" * 60)
          print("üéâ SUCCESS! Video generation complete!")
          print(f"üìÅ Video saved as: {output_filename}")
          print("=" * 60)
      else:
          print("=" * 60)
          print("‚ùå FAILED! Video generation or download failed")
          print("=" * 60)
      
      return success


def main():
  """
  Example usage of the VeoVideoGenerator.
  
  Configure these environment variables:
  - LITELLM_BASE_URL: Your LiteLLM proxy URL (default: https://api.thucchien.ai/gemini/v1beta)
  - LITELLM_API_KEY: Your LiteLLM API key (default: sk-1234)
  """
  
  # Configuration from environment or defaults
  base_url = os.getenv("LITELLM_BASE_URL", "https://api.thucchien.ai/gemini/v1beta")
  api_key = os.getenv("LITELLM_API_KEY", "sk-1234")
  
  print("üöÄ Starting Veo Video Generation Example")
  print(f"üì° Using LiteLLM proxy at: {base_url}")
  
  # Initialize generator
  generator = VeoVideoGenerator(base_url=base_url, api_key=api_key)
  
  # Example prompts - try different ones!
  example_prompts = [
      "A cat playing with a ball of yarn in a sunny garden",
      "Ocean waves crashing against rocky cliffs at sunset",
      "A bustling city street with people walking and cars passing by",
      "A peaceful forest with sunlight filtering through the trees"
  ]
  
  # Use first example or get from user
  prompt = example_prompts[0]
  print(f"üé¨ Using prompt: '{prompt}'")
  
  # Generate and download video
  success = generator.generate_and_download(prompt)
  
  if success:
      print("‚úÖ Example completed successfully!")
      print("üí° Try modifying the prompt in the script for different videos!")
  else:
      print("‚ùå Example failed!")
      print("üîß Check your API Configuration")

if __name__ == "__main__":
  main()

--- python_code_2 ---
#!/usr/bin/env python3
"""
Complete example for Veo video generation through LiteLLM proxy.

This script demonstrates how to:
1. Generate videos using Google's Veo model
2. Poll for completion status
3. Download the generated video file

Requirements:
- LiteLLM proxy running with Google AI Studio pass-through configured
- Google AI Studio API key with Veo access

# This file is forked and adapted from: https://github.com/BerriAI/litellm/blob/main/docs/my-website/docs/proxy/veo_video_generation.md .Please refer to the original for license details.
"""

import json
import os
import time
import requests
from typing import Optional


class VeoVideoGenerator:
  """Complete Veo video generation client using LiteLLM proxy."""
  
  def __init__(self, base_url: str = "https://api.thucchien.ai/gemini/v1beta", 
               api_key: str = "sk-1234"):
      """
      Initialize the Veo video generator.
      
      Args:
          base_url: Base URL for the LiteLLM proxy with Gemini pass-through
          api_key: API key for LiteLLM proxy authentication
      """
      self.base_url = base_url
      self.api_key = api_key
      self.headers = {
          "x-goog-api-key": api_key,
          "Content-Type": "application/json"
      }
  
  def generate_video(self, prompt: str) -> Optional[str]:
      """
      Initiate video generation with Veo.
      
      Args:
          prompt: Text description of the video to generate
          
      Returns:
          Operation name if successful, None otherwise
      """
      print(f"üé¨ Generating video with prompt: '{prompt}'")
      
      url = f"{self.base_url}/models/veo-3.0-generate-preview:predictLongRunning"
      payload = {
          "instances": [{
              "prompt": prompt
          }]
      }
      
      try:
          response = requests.post(url, headers=self.headers, json=payload)
          response.raise_for_status()
          
          data = response.json()
          operation_name = data.get("name")
          
          if operation_name:
              print(f"‚úÖ Video generation started: {operation_name}")
              return operation_name
          else:
              print("‚ùå No operation name returned")
              print(f"Response: {json.dumps(data, indent=2)}")
              return None
              
      except requests.RequestException as e:
          print(f"‚ùå Failed to start video generation: {e}")
          if hasattr(e, 'response') and e.response is not None:
              try:
                  error_data = e.response.json()
                  print(f"Error details: {json.dumps(error_data, indent=2)}")
              except:
                  print(f"Error response: {e.response.text}")
          return None
  
  def wait_for_completion(self, operation_name: str, max_wait_time: int = 600) -> Optional[str]:
      """
      Poll operation status until video generation is complete.
      
      Args:
          operation_name: Name of the operation to monitor
          max_wait_time: Maximum time to wait in seconds (default: 10 minutes)
          
      Returns:
          Video URI if successful, None otherwise
      """
      print("‚è≥ Waiting for video generation to complete...")
      
      operation_url = f"{self.base_url}/{operation_name}"
      start_time = time.time()
      poll_interval = 10  # Start with 10 seconds
      
      while time.time() - start_time < max_wait_time:
          try:
              print(f"üîç Polling status... ({int(time.time() - start_time)}s elapsed)")
              
              response = requests.get(operation_url, headers=self.headers)
              response.raise_for_status()
              
              data = response.json()
              
              # Check for errors
              if "error" in data:
                  print("‚ùå Error in video generation:")
                  print(json.dumps(data["error"], indent=2))
                  return None
              
              # Check if operation is complete
              is_done = data.get("done", False)
              
              if is_done:
                  print("üéâ Video generation complete!")
                  
                  try:
                      # Extract video URI from nested response
                      video_uri = data["response"]["generateVideoResponse"]["generatedSamples"][0]["video"]["uri"]
                      print(f"üìπ Video URI: {video_uri}")
                      return video_uri
                  except KeyError as e:
                      print(f"‚ùå Could not extract video URI: {e}")
                      print("Full response:")
                      print(json.dumps(data, indent=2))
                      return None
              
              # Wait before next poll, with exponential backoff
              time.sleep(poll_interval)
              poll_interval = min(poll_interval * 1.2, 30)  # Cap at 30 seconds
              
          except requests.RequestException as e:
              print(f"‚ùå Error polling operation status: {e}")
              time.sleep(poll_interval)
      
      print(f"‚è∞ Timeout after {max_wait_time} seconds")
      return None
  
  def download_video(self, video_uri: str, output_filename: str = "generated_video.mp4") -> bool:
      """
      Download the generated video file.
      
      Args:
          video_uri: URI of the video to download (from Google's response)
          output_filename: Local filename to save the video
          
      Returns:
          True if download successful, False otherwise
      """
      print(f"‚¨áÔ∏è  Downloading video...")
      print(f"Original URI: {video_uri}")
      
      # Convert Google URI to LiteLLM proxy URI
      # Example: https://generativelanguage.googleapis.com/v1beta/files/abc123 -> /gemini/download/v1beta/files/abc123:download?alt=media
      if video_uri.startswith("https://generativelanguage.googleapis.com/"):
          relative_path = video_uri.replace(
              "https://generativelanguage.googleapis.com/",
              ""
          )
      else:
          relative_path = video_uri

      # base_url: https://api.thucchien.ai/gemini/v1beta
      if self.base_url.endswith("/v1beta"):
          base_path = self.base_url.replace("/v1beta", "/download")
      else:
          base_path = self.base_url

      litellm_download_url = f"{base_path}/{relative_path}"
      print(f"Download URL: {litellm_download_url}")
      
      try:
          # Download with streaming and redirect handling
          response = requests.get(
              litellm_download_url, 
              headers=self.headers, 
              stream=True,
              allow_redirects=True  # Handle redirects automatically
          )
          response.raise_for_status()
          
          # Save video file
          with open(output_filename, 'wb') as f:
              downloaded_size = 0
              for chunk in response.iter_content(chunk_size=8192):
                  if chunk:
                      f.write(chunk)
                      downloaded_size += len(chunk)
                      
                      # Progress indicator for large files
                      if downloaded_size % (1024 * 1024) == 0:  # Every MB
                          print(f"üì¶ Downloaded {downloaded_size / (1024*1024):.1f} MB...")
          
          # Verify file was created and has content
          if os.path.exists(output_filename):
              file_size = os.path.getsize(output_filename)
              if file_size > 0:
                  print(f"‚úÖ Video downloaded successfully!")
                  print(f"üìÅ Saved as: {output_filename}")
                  print(f"üìè File size: {file_size / (1024*1024):.2f} MB")
                  return True
              else:
                  print("‚ùå Downloaded file is empty")
                  os.remove(output_filename)
                  return False
          else:
              print("‚ùå File was not created")
              return False
              
      except requests.RequestException as e:
          print(f"‚ùå Download failed: {e}")
          if hasattr(e, 'response') and e.response is not None:
              print(f"Status code: {e.response.status_code}")
              print(f"Response headers: {dict(e.response.headers)}")
          return False
  
  def generate_and_download(self, prompt: str, output_filename: str = None) -> bool:
      """
      Complete workflow: generate video and download it.
      
      Args:
          prompt: Text description for video generation
          output_filename: Output filename (auto-generated if None)
          
      Returns:
          True if successful, False otherwise
      """
      # Auto-generate filename if not provided
      if output_filename is None:
          timestamp = int(time.time())
          safe_prompt = "".join(c for c in prompt[:30] if c.isalnum() or c in (' ', '-', '_')).rstrip()
          output_filename = f"veo_video_{safe_prompt.replace(' ', '_')}_{timestamp}.mp4"
      
      print("=" * 60)
      print("üé¨ VEO VIDEO GENERATION WORKFLOW")
      print("=" * 60)
      
      # Step 1: Generate video
      operation_name = self.generate_video(prompt)
      if not operation_name:
          return False
      
      # Step 2: Wait for completion
      video_uri = self.wait_for_completion(operation_name)
      if not video_uri:
          return False
      
      # Step 3: Download video
      success = self.download_video(video_uri, output_filename)
      
      if success:
          print("=" * 60)
          print("üéâ SUCCESS! Video generation complete!")
          print(f"üìÅ Video saved as: {output_filename}")
          print("=" * 60)
      else:
          print("=" * 60)
          print("‚ùå FAILED! Video generation or download failed")
          print("=" * 60)
      
      return success


def main():
  """
  Example usage of the VeoVideoGenerator.
  
  Configure these environment variables:
  - LITELLM_BASE_URL: Your LiteLLM proxy URL (default: https://api.thucchien.ai/gemini/v1beta)
  - LITELLM_API_KEY: Your LiteLLM API key (default: sk-1234)
  """
  
  # Configuration from environment or defaults
  base_url = os.getenv("LITELLM_BASE_URL", "https://api.thucchien.ai/gemini/v1beta")
  api_key = os.getenv("LITELLM_API_KEY", "sk-1234")
  
  print("üöÄ Starting Veo Video Generation Example")
  print(f"üì° Using LiteLLM proxy at: {base_url}")
  
  # Initialize generator
  generator = VeoVideoGenerator(base_url=base_url, api_key=api_key)
  
  # Example prompts - try different ones!
  example_prompts = [
      "A cat playing with a ball of yarn in a sunny garden",
      "Ocean waves crashing against rocky cliffs at sunset",
      "A bustling city street with people walking and cars passing by",
      "A peaceful forest with sunlight filtering through the trees"
  ]
  
  # Use first example or get from user
  prompt = example_prompts[0]
  print(f"üé¨ Using prompt: '{prompt}'")
  
  # Generate and download video
  success = generator.generate_and_download(prompt)
  
  if success:
      print("‚úÖ Example completed successfully!")
      print("üí° Try modifying the prompt in the script for different videos!")
  else:
      print("‚ùå Example failed!")
      print("üîß Check your API Configuration")

if __name__ == "__main__":
  main()

--- unknown_code_28 ---
#!/usr/bin/env python3
"""
Complete example for Veo video generation through LiteLLM proxy.

This script demonstrates how to:
1. Generate videos using Google's Veo model
2. Poll for completion status
3. Download the generated video file

Requirements:
- LiteLLM proxy running with Google AI Studio pass-through configured
- Google AI Studio API key with Veo access

# This file is forked and adapted from: https://github.com/BerriAI/litellm/blob/main/docs/my-website/docs/proxy/veo_video_generation.md .Please refer to the original for license details.
"""

import json
import os
import time
import requests
from typing import Optional


class VeoVideoGenerator:
  """Complete Veo video generation client using LiteLLM proxy."""
  
  def __init__(self, base_url: str = "https://api.thucchien.ai/gemini/v1beta", 
               api_key: str = "sk-1234"):
      """
      Initialize the Veo video generator.
      
      Args:
          base_url: Base URL for the LiteLLM proxy with Gemini pass-through
          api_key: API key for LiteLLM proxy authentication
      """
      self.base_url = base_url
      self.api_key = api_key
      self.headers = {
          "x-goog-api-key": api_key,
          "Content-Type": "application/json"
      }
  
  def generate_video(self, prompt: str) -> Optional[str]:
      """
      Initiate video generation with Veo.
      
      Args:
          prompt: Text description of the video to generate
          
      Returns:
          Operation name if successful, None otherwise
      """
      print(f"üé¨ Generating video with prompt: '{prompt}'")
      
      url = f"{self.base_url}/models/veo-3.0-generate-preview:predictLongRunning"
      payload = {
          "instances": [{
              "prompt": prompt
          }]
      }
      
      try:
          response = requests.post(url, headers=self.headers, json=payload)
          response.raise_for_status()
          
          data = response.json()
          operation_name = data.get("name")
          
          if operation_name:
              print(f"‚úÖ Video generation started: {operation_name}")
              return operation_name
          else:
              print("‚ùå No operation name returned")
              print(f"Response: {json.dumps(data, indent=2)}")
              return None
              
      except requests.RequestException as e:
          print(f"‚ùå Failed to start video generation: {e}")
          if hasattr(e, 'response') and e.response is not None:
              try:
                  error_data = e.response.json()
                  print(f"Error details: {json.dumps(error_data, indent=2)}")
              except:
                  print(f"Error response: {e.response.text}")
          return None
  
  def wait_for_completion(self, operation_name: str, max_wait_time: int = 600) -> Optional[str]:
      """
      Poll operation status until video generation is complete.
      
      Args:
          operation_name: Name of the operation to monitor
          max_wait_time: Maximum time to wait in seconds (default: 10 minutes)
          
      Returns:
          Video URI if successful, None otherwise
      """
      print("‚è≥ Waiting for video generation to complete...")
      
      operation_url = f"{self.base_url}/{operation_name}"
      start_time = time.time()
      poll_interval = 10  # Start with 10 seconds
      
      while time.time() - start_time < max_wait_time:
          try:
              print(f"üîç Polling status... ({int(time.time() - start_time)}s elapsed)")
              
              response = requests.get(operation_url, headers=self.headers)
              response.raise_for_status()
              
              data = response.json()
              
              # Check for errors
              if "error" in data:
                  print("‚ùå Error in video generation:")
                  print(json.dumps(data["error"], indent=2))
                  return None
              
              # Check if operation is complete
              is_done = data.get("done", False)
              
              if is_done:
                  print("üéâ Video generation complete!")
                  
                  try:
                      # Extract video URI from nested response
                      video_uri = data["response"]["generateVideoResponse"]["generatedSamples"][0]["video"]["uri"]
                      print(f"üìπ Video URI: {video_uri}")
                      return video_uri
                  except KeyError as e:
                      print(f"‚ùå Could not extract video URI: {e}")
                      print("Full response:")
                      print(json.dumps(data, indent=2))
                      return None
              
              # Wait before next poll, with exponential backoff
              time.sleep(poll_interval)
              poll_interval = min(poll_interval * 1.2, 30)  # Cap at 30 seconds
              
          except requests.RequestException as e:
              print(f"‚ùå Error polling operation status: {e}")
              time.sleep(poll_interval)
      
      print(f"‚è∞ Timeout after {max_wait_time} seconds")
      return None
  
  def download_video(self, video_uri: str, output_filename: str = "generated_video.mp4") -> bool:
      """
      Download the generated video file.
      
      Args:
          video_uri: URI of the video to download (from Google's response)
          output_filename: Local filename to save the video
          
      Returns:
          True if download successful, False otherwise
      """
      print(f"‚¨áÔ∏è  Downloading video...")
      print(f"Original URI: {video_uri}")
      
      # Convert Google URI to LiteLLM proxy URI
      # Example: https://generativelanguage.googleapis.com/v1beta/files/abc123 -> /gemini/download/v1beta/files/abc123:download?alt=media
      if video_uri.startswith("https://generativelanguage.googleapis.com/"):
          relative_path = video_uri.replace(
              "https://generativelanguage.googleapis.com/",
              ""
          )
      else:
          relative_path = video_uri

      # base_url: https://api.thucchien.ai/gemini/v1beta
      if self.base_url.endswith("/v1beta"):
          base_path = self.base_url.replace("/v1beta", "/download")
      else:
          base_path = self.base_url

      litellm_download_url = f"{base_path}/{relative_path}"
      print(f"Download URL: {litellm_download_url}")
      
      try:
          # Download with streaming and redirect handling
          response = requests.get(
              litellm_download_url, 
              headers=self.headers, 
              stream=True,
              allow_redirects=True  # Handle redirects automatically
          )
          response.raise_for_status()
          
          # Save video file
          with open(output_filename, 'wb') as f:
              downloaded_size = 0
              for chunk in response.iter_content(chunk_size=8192):
                  if chunk:
                      f.write(chunk)
                      downloaded_size += len(chunk)
                      
                      # Progress indicator for large files
                      if downloaded_size % (1024 * 1024) == 0:  # Every MB
                          print(f"üì¶ Downloaded {downloaded_size / (1024*1024):.1f} MB...")
          
          # Verify file was created and has content
          if os.path.exists(output_filename):
              file_size = os.path.getsize(output_filename)
              if file_size > 0:
                  print(f"‚úÖ Video downloaded successfully!")
                  print(f"üìÅ Saved as: {output_filename}")
                  print(f"üìè File size: {file_size / (1024*1024):.2f} MB")
                  return True
              else:
                  print("‚ùå Downloaded file is empty")
                  os.remove(output_filename)
                  return False
          else:
              print("‚ùå File was not created")
              return False
              
      except requests.RequestException as e:
          print(f"‚ùå Download failed: {e}")
          if hasattr(e, 'response') and e.response is not None:
              print(f"Status code: {e.response.status_code}")
              print(f"Response headers: {dict(e.response.headers)}")
          return False
  
  def generate_and_download(self, prompt: str, output_filename: str = None) -> bool:
      """
      Complete workflow: generate video and download it.
      
      Args:
          prompt: Text description for video generation
          output_filename: Output filename (auto-generated if None)
          
      Returns:
          True if successful, False otherwise
      """
      # Auto-generate filename if not provided
      if output_filename is None:
          timestamp = int(time.time())
          safe_prompt = "".join(c for c in prompt[:30] if c.isalnum() or c in (' ', '-', '_')).rstrip()
          output_filename = f"veo_video_{safe_prompt.replace(' ', '_')}_{timestamp}.mp4"
      
      print("=" * 60)
      print("üé¨ VEO VIDEO GENERATION WORKFLOW")
      print("=" * 60)
      
      # Step 1: Generate video
      operation_name = self.generate_video(prompt)
      if not operation_name:
          return False
      
      # Step 2: Wait for completion
      video_uri = self.wait_for_completion(operation_name)
      if not video_uri:
          return False
      
      # Step 3: Download video
      success = self.download_video(video_uri, output_filename)
      
      if success:
          print("=" * 60)
          print("üéâ SUCCESS! Video generation complete!")
          print(f"üìÅ Video saved as: {output_filename}")
          print("=" * 60)
      else:
          print("=" * 60)
          print("‚ùå FAILED! Video generation or download failed")
          print("=" * 60)
      
      return success


def main():
  """
  Example usage of the VeoVideoGenerator.
  
  Configure these environment variables:
  - LITELLM_BASE_URL: Your LiteLLM proxy URL (default: https://api.thucchien.ai/gemini/v1beta)
  - LITELLM_API_KEY: Your LiteLLM API key (default: sk-1234)
  """
  
  # Configuration from environment or defaults
  base_url = os.getenv("LITELLM_BASE_URL", "https://api.thucchien.ai/gemini/v1beta")
  api_key = os.getenv("LITELLM_API_KEY", "sk-1234")
  
  print("üöÄ Starting Veo Video Generation Example")
  print(f"üì° Using LiteLLM proxy at: {base_url}")
  
  # Initialize generator
  generator = VeoVideoGenerator(base_url=base_url, api_key=api_key)
  
  # Example prompts - try different ones!
  example_prompts = [
      "A cat playing with a ball of yarn in a sunny garden",
      "Ocean waves crashing against rocky cliffs at sunset",
      "A bustling city street with people walking and cars passing by",
      "A peaceful forest with sunlight filtering through the trees"
  ]
  
  # Use first example or get from user
  prompt = example_prompts[0]
  print(f"üé¨ Using prompt: '{prompt}'")
  
  # Generate and download video
  success = generator.generate_and_download(prompt)
  
  if success:
      print("‚úÖ Example completed successfully!")
      print("üí° Try modifying the prompt in the script for different videos!")
  else:
      print("‚ùå Example failed!")
      print("üîß Check your API Configuration")

if __name__ == "__main__":
  main()
